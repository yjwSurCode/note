https://developers.google.com/web/updates/2018/09/inside-browser-part1

从输入 URL 到页面加载完成的过程中都发生了什么事情（https://fex.baidu.com/blog/2014/05/what-happen）

1. 构建请求------查找强缓存----DNS解析------建立 TCP 连接（Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接,超过 6 个的话剩下的请求就得等待）
4：发送 HTTP 请求-----网络响应
5：浏览器将获取的HTML文档由HTML解析器解析成DOM树（Document Object Model）。
6：同时由CSS解析器将CSS样式解析成CSS规则树（CSS Rule Tree）。
7：将生成的DOM树和CSS规则树合并生成渲染树（Rendering Tree）。
8：在绘制(painting)阶段,渲染引擎会遍历Render树,并调用renderer的 paint() 方法,将renderer的内容显示在屏幕上
9:js渲染-----------------css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析
10：客户端与服务器进行TCP的四次挥手。


eg：首先,当我们是要浏览一个网页,我们会在浏览器的地址栏里输入URL,这个时候Browser Process会向这个URL发送请求,获取这个URL的HTML内容,
然后将HTML交给Renderer Process,Renderer Process解析HTML内容,解析遇到需要请求网络的资源又返回来交给Browser Process进行加载,
同时通知Browser Process,需要Plugin Process加载插件资源,执行插件代码。解析完成后Renderer Process计算得到图像帧,并将这些图像帧交给GPU Process,GPU Process将其转化为图像显示屏幕。



https的握手过程：：：：：：
客户端使用https的url访问web服务器,要求与服务器建立ssl连接
web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
之后服务器与客户端使用秘钥加密传输


布局---回流---重绘：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
1：第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流
2：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
3：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

会导致回流的操作：：：：：：
页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
激活CSS伪类（例如：:hover）
查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
scrollIntoView()、scrollIntoViewIfNeeded()
getComputedStyle()
getBoundingClientRect()
scrollTo()

(回流必将引起重绘,重绘不一定会引起回流)

回流重绘的优化：：：：：：：：：：：：：：：：：
使用 transform 替代 top
使用 visibility 替换 display: none ,因为前者只会引起重绘,后者会引发回流
改变了布局避免使用table布局,可能很小的一个小改动会造成整个 table 的重新布局。

 css 加载会造成阻塞吗 ？:::::::::::::::::::::::::::::::::::::::::::::
 DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。
 然而,由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的,所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。
 因此,CSS 加载会阻塞 Dom 的渲染。

谈一谈你对requestAnimationFrame（rAF）理解::::::::::::::::::
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行------cancelAnimationFrame(requestId)

每一帧要在 16.7ms (16.7 = 1000/60) 内完成渲染

rAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次(上一个知识点刚刚梳理完「函数节流」)，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。


同源策略是一个安全策略。所谓的同源,指的是协议,域名,端口相同。
浏览器处于安全方面的考虑,只允许本域名下的接口交互,不同源的客户端脚本,在没有明确授权的情况下,不能读写对方的资源。

解决跨域：
1：Node中间件代理(两次跨域) （前端先访问已设置Cors的后端1,再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端）             document.domain + iframe   location.hash + iframe
2：Proxy代理跨域
3：WebSocket解决跨域
地址：https://juejin.cn/post/7075261878997352462


浏览器兼容性问题 ：：：：：：：：：：：




浏览器的本地存储 ：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
Cookie: 体积上限只有4KB。 由于 Cookie 以纯文本的形式在浏览器和服务器中传递
localStorage :只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。
sessionStorage：会话结束，也就是页面关闭，这部分sessionStorage就不复存在了。


web安全：：：：：：：：：：：
1 XSS 攻击的本质是将用户数据当成了 HTML 代码一部分来执行，从而混淆原本的语义，产生新的语义。
2 CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，「CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。」
https://juejin.cn/post/6844903842635579405#heading-5


GET 和 POST 的区别::::
GET在浏览器回退时是无害的，而POST会再次发起请求
GET请求会被浏览器主动缓存，而POST不会，除非手动设置
GET请求只能进行URL编码，而POST支持多种编码方式
GET没有POST安全，因为GET请求参数直接暴露在URL上，所以不能用来传递敏感信息
GET产生一个TCP数据包，POST产生两个数据包(Firefox只发一次)。GET浏览器把 http header和data一起发出去，响应成功200，POST先发送header，响应100 continue，再发送data，响应成功200



HTTP 和 HTTPS 的区别 ：：：：：：：：：：：：：：：：：：：：：：：：：
HTTP是明文传输，不安全的，HTTPS是加密传输，安全的多
HTTP标准端口是80，HTTPS标准端口是443
HTTP不用认证证书免费，HTTPS需要认证证书要钱
连接方式不同，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次
HTTP在OSI网络模型中是在应用层，而HTTPS的TLS是在传输层
HTTP是无状态的，HTTPS是有状态的




回收机制：
一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。




// 2:浏览器渲染机制
// DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。
// CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构，简称CSSOM。
// Render Tree: DOM和CSSOM合并后生成Render Tree
// Repaint ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。
// Reflow ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。
// reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
// 注：display: none会触发reflow，而visibility: hidden只会触发repaint，因为没有发现位置变化。





js的执行机制：：：：：：：：：：：：：：：
js只能是单线程-------------假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

进程---线程 ：：：：：：：：：：：：：：：：：：：：：：：：：：
进程：是 CPU 资源分配的最小单位可以理解成正在执行的应用程序，
线程：是 CPU 调度的最小单位，可以理解成我们应用程序中的代码的执行器。而他们的关系可想而知，
线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，而一个线程，只能隶属于一个进程。
GUI 渲染线程：负责渲染浏览器界面,解析 HTML,CSS,构建 DOM 树和 RenderObject 树,布局和绘制等。
JS 引擎线程：javascript 引擎,也称为 JS 内核,负责处理 Javascript 脚本程序（v8引擎）
这个引擎(V8)主要由两部分组成:
内存堆：这是内存分配发生的地方
调用栈：这是你的代码执行时的地方
GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。



事件循环是js实现异步的一种方法，也是js的执行机制：：：：：：：：：：：：：
外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->
定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段..

同步任务--异步任务（分为宏任务,微任务）
macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
micro-task(微任务)：Promise，process.nextTick
在线调试地址：https://www.jsv9000.app/

async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式
然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

1  7 6 8 2 4 3 5 9  10 11 12

eg:  6之后执行8  是因为 6是第一个微服务 执行完微服务要执行所有的微服务

eg: 2，4 ，3，5     ,,24之后要执行完这里的微服务再执行下面的微服务。下面的setimeOut是第三轮的事件循环宏服务


console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

process.nextTick(function() {
    console.log('6');
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

前端模块化：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
window----IIFE-------AMD-------CMD---------CommonJs----ESM

异步模块定义规范(AMD)制定了定义模块的规则,这样模块和模块的依赖可以被异步加载。
这和浏览器的异步加载模块的环境刚好适应(浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题)
AMD 是一种异步模块规范,RequireJS 是 AMD 规范的实现

// IIFE 创建自执行函数
var testUtils = function () {
    function test(data){
        console.log(data)
    }
    return {
      test
    }
}()


// AMD（RequireJS）
 依赖必须一开始就写好
define(['./utils'], function(utils) {
  utils.request();
});

// CMD----跟requireJS解决同样问题，只是运行机制不同。
define(function(require) {
  依赖可以就近书写
  var utils = require('./utils');
  utils.request();
});

//CommonJS
随着 node 诞生，服务器端的模块规范 CommonJS 被创建出来。
var config = require('./config');
const {
    notExistFold,
    prompt,
} = require('./util.js');

module.exports = NAME
exports = NAME

ES6 module：(目前的浏览器还没有全部兼容 需要使用bable进行处理)
import api from './config.js';
import { api as myApi } from './config.js';

export const prefix = 'https://github.com';
export default function foo() {}

ES6 module 使用import导入模块接口
import { api as myApi } from './config.js';

import()实现按需加载






// offlineHandle.js
import React, { useState, useEffect } from "react";
import { notification } from "antd";
import "antd/dist/antd.css";
import "./index.css";

const OfflineHandle = (props) => {
  const {
    offlineTitle = "网络已断开，请检查网络连接。",
    onlineTitle = "网络已连接",
    desc,
    duration = 4.5
  } = props;
  const [mask, setMask] = useState(false);

  const eventHandler = (event) => {
    const type = event.type === "offline" ? "error" : "success";
    console.log(desc, "desc");
    openNotification({
      type,
      title: type === "error" ? offlineTitle : onlineTitle,
      desc: type === "error" ? desc : "",
      duration
    });
    setTimeout(() => {
      setMask(event.type === "offline");
    }, 1500);
  };

  const openNotification = ({ type, title, desc, duration }) => {
    notification[type]({
      message: title,
      description: desc,
      duration
    });
  };

  useEffect(() => {
    window.addEventListener("offline", eventHandler);
    window.addEventListener("online", eventHandler);
    return () => {
      window.removeEventListener("offline", eventHandler);
      window.removeEventListener("online", eventHandler);
    };
  }, []);

  const renderOfflineMask = () => {
    if (!mask) return null;
    return (
      <div className="offline-mask">
        <h2 className="offline-mask-title">{offlineTitle}</h2>

        <p className="offline-mask-desc">{desc}</p>
      </div>
    );
  };

  return <>{renderOfflineMask()}</>;
};

export default OfflineHandle;



一文吃透 React SSR 服务端渲染和同构原理::::::::




debug:

按钮1：运行/继续 F5，真正的一步一步运行
按钮2：单步跳过(又叫逐过程) F10，按语句单步执行。当有函数时，不会进入函数。
按钮3：单步调试（又叫逐语句）F11：当有函数时，点击这个按钮，会进入这个函数内
按钮4：单步跳出 ⇧F11:如果有循环，点击该按钮，会执行到循环外面的语句。
按钮5：重启 ⇧⌘F5：
按钮5：停止 ⇧F5：


浏览器工作原理：https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work

渲染流程图：https://segmentfault.com/a/1190000037650883

react fiber : https://segmentfault.com/a/1190000039682751

react fiber : https://juejin.cn/post/6984949525928476703

react 技术揭秘：https://react.iamkasong.com/hooks/usememo.html#mount

react 预览官网 https://reactjs.org/docs/concurrent-mode-intro.html

react github https://github1s.com/facebook/react

vue3 https://github1s.com/vuejs/vue-next/blob/HEAD/packages/vue/index.js

react hooks 使用注意的细节：https://zhuanlan.zhihu.com/p/85969406

svg教程视频： https://www.bilibili.com/video/BV1Y54y1C7M9?spm_id_from=333.999.0.0

canvas 教程视频： https://www.bilibili.com/video/BV1Ri4y1M7NT?spm_id_from=333.999.0.0

浏览器断网提示：https://segmentfault.com/a/1190000022203425


扩展： webRtc


前端常用linux命令：https://juejin.cn/post/7044099175838908424

react路由拦截：https://juejin.cn/post/6871018004289683463







扩展 webRtc：：：：Real Time Communications


webSocket 如何兼容低浏览器 ？

Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于 multipart 编码发送 XHR 、
基于长轮询的 XHR。


SEO优化说白了就是使得自己的网站对于搜索引擎的爬虫更加友好，目前单页面应用的大部分做法是使用前端框架，导致主页面没有相关的描述信息，详细信息大部分都是动态生成的，对于爬虫来说去准确模拟相关的行为获取符合数据是很困难的（对于如此大规模的数据来说）

