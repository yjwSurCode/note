https://developers.google.com/web/updates/2018/09/inside-browser-part1

# 从输入 URL 到页面加载完成的过程中都发生了什么事情（https://fex.baidu.com/blog/2014/05/what-happen）
1：构建请求------查找强缓存----DNS解析------建立 TCP 连接 三次握手
4：发送 HTTP 请求-----网络响应
5：浏览器将获取的HTML文档由HTML解析器解析成DOM树（Document Object Model）。
6：同时由CSS解析器将CSS样式解析成CSS规则树（CSS Rule Tree）。
7：将生成的DOM树和CSS规则树合并生成渲染树（Rendering Tree）。
8：在绘制(painting)阶段,渲染引擎会遍历Render树,并调用renderer的 paint() 方法,将renderer的内容显示在屏幕上
9:js渲染-----------------css加载会阻塞后面js语句的执行,而(同步)js脚本执行会阻塞其后的DOM解析
10：客户端与服务器进行TCP的四次挥手。


eg：首先,当我们是要浏览一个网页,我们会在浏览器的地址栏里输入URL,这个时候Browser Process会向这个URL发送请求,获取这个URL的HTML内容,
然后将HTML交给Renderer Process,Renderer Process解析HTML内容,解析遇到需要请求网络的资源又返回来交给Browser Process进行加载,
同时通知Browser Process,需要Plugin Process加载插件资源,执行插件代码。解析完成后Renderer Process计算得到图像帧,并将这些图像帧交给GPU Process,GPU Process将其转化为图像显示屏幕。



# https的握手过程：：：：：：
客户端使用https的url访问web服务器,要求与服务器建立ssl连接
web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
之后服务器与客户端使用秘钥加密传输


# 布局---回流(reflow)---重绘(repaint)：：：：：：：：：
1：第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流
2：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时,浏览器重新渲染部分或全部文档的过程称为回流。
3：当页面中元素样式的改变并不影响它在文档流中的位置时（例如 color、background-color、visibility等）,浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘
(回流必将引起重绘,重绘不一定会引起回流)

# 会导致回流的操作：：：：：：
页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
激活CSS伪类（例如：:hover）
查询某些属性或调用某些方法

#  一些常用且会导致回流的属性和方法：：：：：：：
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
scrollIntoView()、scrollIntoViewIfNeeded()
getComputedStyle()
getBoundingClientRect()
scrollTo()



# 回流的优化：：：：：：：：：：：：：：：：：
1：使用 transform 替代 top (node.style.left="100px")  (node.style.transform="translateX(100px)")
2：不要一次一次的修改样式,而是预先定义好class,直接修改DOM的className,这样只会引发一次重排重绘
3：使用 visibility 替换 display: none ,因为前者只会引起重绘,后者会引发回流
4：改变了布局避免使用table布局,可能很小的一个小改动会造成整个 table 的重新布局。


# 浏览器渲染机制:::::::::::::::::::::::::::::::::
DOM：Document Object Model，浏览器将HTML解析成树形的数据结构,简称DOM。
CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构,简称CSSOM。
RenderTree： DOM和CSSOM合并后生成Render Tree
Repaint ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。
Reflow ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。
reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
注：display: none会触发reflow，而visibility: hidden只会触发repaint，因为没有发现位置变化。


# css 加载会造成阻塞吗？:::::::::::::::::::::::::::::::::::::::::::::
css加载不会阻塞DOM树的解析?----------------下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。
css加载会阻塞DOM树的渲染?
css加载会阻塞后面js语句的执行?

回答1:DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞DOM 的解析。
回答2:然而由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的,所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。
因此,CSS 加载会阻塞 DOM 的渲染。
回答3:css动画会触发重绘,重绘阻塞js页面

# js 加载会造成阻塞吗？:::::::::::::::::::::::::::::::::::::::::::::
JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因

# 谈一谈你对requestAnimationFrame（RAF）理解::::::::::::::::::
window.requestAnimationFrame()告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行------cancelAnimationFrame(requestId)
每一帧要在 16.7ms (16.7 = 1000/60) 内完成渲染
RAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次(上一个知识点刚刚梳理完「函数节流」)，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。



# 解决跨域：(https://juejin.cn/post/7075261878997352462)
1：Node中间件代理(两次跨域) （前端先访问已设置Cors的后端1,再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端）             document.domain + iframe   location.hash + iframe
2：Proxy代理跨域
3：WebSocket解决跨域
4：jsonp解决跨域(就是在script标签上面加载资源)
5：后端请求头上面加cors

同源策略是一个安全策略。所谓的同源,指的是协议,域名,端口相同。
浏览器处于安全方面的考虑,只允许本域名下的接口交互,不同源的客户端脚本,在没有明确授权的情况下,不能读写对方的资源。

# 测试跨域
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://47.93.20.245:8710/home/carbon/emission');
xhr.setRequestHeader("Content-type","application/json;charset=UTF-8");
xhr.setRequestHeader("jwt-token","JhbGciOiJSUzI1N");
xhr.send('{"pageSize":"10","pageNo":"1"}');
xhr.onload = function(e) {
var xhr = e.target;
console.log(xhr.responseText);
}

ƒ (e) {
var xhr = e.target;
console.log(xhr.responseText);
}

# 深度剖析TCP与UDP的区别
https://juejin.cn/post/6992743999756845087

# TCP优点
1：确认和重传机制 三次握手同步双方的序号,确认号,窗口大小,是确认重传和流量控制的基础。
在传输过程中，如果校验和校验失败，丢包或者延时，发送端会立马重传。
2：数据排序 有专门的序号字段,可以提供数据re-order。
3：流量控制 窗口字段可以指明双方最大的数据传输和接受量
4：拥塞控制 由四个核心算法实现：慢启动，拥塞避免，快速重传，快速恢复

# 应用场景
tcp(传输控制协议),提供的是可靠的运输,基于连接同时也说明需要的时间更长。应用于需要可靠性较高的场所。http请求,文件传输等等。
udp不基于连接。速度更快,应用于网络通讯速度较快的场景。比如语音电话、视频、直播等等。


#解读 HTTP1/HTTP2/HTTP3
https://juejin.cn/post/6995109407545622542

# HTTP2
1：二进制传输
2：Header 压缩
2：多路复用:可以只通过一个 TCP 连接就可以传输所有的请求数据。

HTTP/1.1有两个主要的缺点：安全不足和性能不高。
HTTP/2完全兼容HTTP/1，是"更安全的HTTP、更快的HTTPS"，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验
QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。


# 浏览器的本地存储 ：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
Cookie：体积上限只有4KB。 由于 Cookie 以纯文本的形式在浏览器和服务器中传递(cookie会跟随任意HTTP请求一起发送)
localStorage：只存在客户端,默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。
sessionStorage：会话结束,也就是页面关闭,这部分sessionStorage就不复存在了。


# web安全 网络安全 (https://juejin.cn/post/6844903842635579405#heading-5)   `https://www.eggjs.org/zh-CN/core/security`
1：XSS 攻击的本质是将用户数据当成了 HTML 代码一部分来执行，从而混淆原本的语义，产生新的语义。
模拟获取cookie-----http://localhost:3000/?from=<script src="http://localhost:4000/hack.js">

2 CSRF 英文全称是 Cross-site request forgery,所以又称为“跨站请求伪造”,是指黑客引诱用户打开黑客的网站,在黑客的网站中,利用用户的登录状态发起的跨站请求。简单来讲,「CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。」

# 措施：
对数据进行严格的输出编码：如HTML元素的编码,JS编码,CSS编码,URL编码等等
输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断
验证码
token


# 浏览器缓存 :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
强缓存：
当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制
协商缓存：
发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。


# GET 和 POST 的区别:::::::::::::::::::::::::::::::
1：GET在浏览器回退时是无害的,而POST会再次发起请求。
2：GET请求会被浏览器主动缓存,而POST不会,除非手动设置。
3：GET请求只能进行URL编码,而POST支持多种编码方式 。
4：GET没有POST安全,因为GET请求参数直接暴露在URL上,所以不能用来传递敏感信息。
5：GET浏览器把 http header和data一起发出去,响应成功200 POST先发送header,响应100 continue,再发送data,响应成功200  GET产生一个TCP数据包,POST产生两个数据包(Firefox只发一次)。


# http请求头
Host 接受请求的服务器地址,可以是P端口号,也可以是域名
User-Agent：发送请求的应用程序名称
Connection：定与连接相关的属性 如Connection:Keep-Alve
Accept-Charset：通知服务端可以发送的编码格式
Accept-Encoding：通服务端可以发送的数据压缩格式
Accept-Language：通知服务端可以发送语言

# HTTP 和 HTTPS 的区别 ：：：：：：：：：：：：：：：：：
HTTP是明文传输,不安全的,HTTPS是加密传输,安全的多
HTTP标准端口是80,HTTPS标准端口是443
HTTP不用认证证书免费,HTTPS需要认证证书要钱
连接方式不同,HTTP三次握手,HTTPS中TLS1.2版本7次,TLS1.3版本6次
HTTP在OSI网络模型中是在应用层,而HTTPS的TLS是在传输层
HTTP是无状态的,HTTPS是有状态的

# 回收机制::::::::::::::::::::::::::
垃圾回收机制的原理:是找到不再继续使用的变量，释放其内存。垃圾回收器会按照固定的时间间隔(或代码中预定的收集时间)，周期性地执行这一操作;

Javascript 会找出不再使用的变量,不再使用意味着这个变量生命周期的结束。Javascript 中存在两种变量——全局变量和局部变量，
全部变量：的声明周期会一直持续，直到页面卸载;
局部变量：声明在函数中，它的声明周期从执行函数开始，直到函数执行结束。
在这个过程中，局部变量会在堆或栈上被分配相应的空间以存储它们的值，函数执行结束，这些局部变量也不再被使用，它们所占用的空间也就被释放;
一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

# 内存泄漏 (它将可能引起程序的卡顿和崩溃;)::::::::::::::::::::::::::
意外的全局变量
被忘记的定时器或者回调函数
闭包
DOM泄漏
浏览器中DOM和js采用的是不一样的引擎,DOM采用的是渲染引擎,而js采用的是v8引擎


# 三次握手 四次挥手
TCP 是可以双向传输数据的，也就是全双工协议。所以双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。
<img src="https://pica.zhimg.com/50/v2-92888df73d4608c0a1970c5032612c48_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="753" data-rawheight="794" data-original-token="v2-74ff931c195a06096cb85069458914b3" data-default-watermark-src="" class="origin_image zh-lightbox-thumb" width="753" data-original=""/>
客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。
服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。
客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。等待服务端处理完数据后，也向客户端发送 FIN 报文，
之后服务端进入 LAST_ACK 状态。客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态服务器收到了 ACK 应答报文后，
就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，
至此客户端也完成连接的关闭。你可以看到，每个方向都需要一个 FIN 和一个 ACK，
因此通常被称为四次挥手。这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。

# 为什么挥手需要四次？
再来回顾下四次挥手双方发FIN包的过程,就能理解为什么需要四次了。关闭连接时,客户端向服务端发送FIN时,仅仅表示客户端不再发送数据了但是还能接收数据。
服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
从上面过程可知，服务端通常需要等待完成数据的发送和处理，`所以服务端的 ACK 和 FIN 一般都会分开发送,从而比三次握手导致多了一次`。
#TCP 挥手可以只需要三次吗？
可以的。因为服务器端收到客户端的FIN后,服务器端同时也要关闭连接,这样就可以把ACK和FIN合并到一起发送,节省了一个包,变成了“三次挥手”。

# 浏览器兼容性问题 ：：：：：：：：：：：
原因:浏览器各浏览器使用了不同的内核，并且它们处理同一件事情的时候思路不同。

@vitejs/plugin-legacy

1:通过rollup构建了面向低版本的资源 
rollup cjs esm umd
2:在html入口增加了nomodule的兼容

### js兼容性
可以使用 const 关键字或 var 关键字来定义常量；IE下，只能使用 var 关键字来定义常量。
解决方案：统一使用 var 关键字来定义常量。

### css兼容性:
			postcss: {
				plugins: [
					autoprefixer({
						overrideBrowserslist: COMPILE_TARGETS,
					}),
				],
			}
🌰
* html .test { color: #090; }       /* For IE6 and earlier */
* + html .test { color: #ff0; }     /* For IE7 */

### 浏览器前缀
.container {
	display: flex;
	flex-direction: row;
}
需要增加兼容 chrome49 以及 chrome79 以上的样式
.container {
	display: flex;
	flex-direction: column;
	height: 100%;
	min-height: 0;
}

1： terser + Rollup 兼容旧浏览器
import { terser } from 'rollup-plugin-terser';
import getBabelOutputPlugin from '@rollup/plugin-babel';

export default {
  input: 'src/load.js',
  plugins: [
    // https://github.com/terser/terser#minify-options
    terser({
      ecma: '5',
      compress: true,
      mangle: true,
    }),
    getBabelOutputPlugin({
      babelHelpers: 'bundled',
      presets: [
        ['@babel/preset-env', {
          targets: '> 0.25%, last 2 versions, Firefox ESR, not dead',
        }],
      ],
    }),
  ],
  output: {
    file: 'dist/load.js',
    format: 'iife',
    sourcemap: false,
  },
};


# js的执行机制：：：：：：：：：：：：：：：
js只能是单线程-------------假定JavaScript同时有两个线程,一个线程在某个DOM节点上添加内容,另一个线程删除了这个节点,这时浏览器应该以哪个线程为准？

# 进程---线程 （进（线程）程）：：：：：：：：：：：：：：：：：：：：：：：：：：
进程：是 CPU 资源分配的最小单位可以理解成正在执行的应用程序，
线程：是 CPU 调度的最小单位，可以理解成我们应用程序中的代码的执行器。而他们的关系可想而知，
线程是跑在进程里面的,`一个进程里面可能有一个或者多个线程，而一个线程，只能隶属于一个进程`。
GUI 渲染线程：负责渲染浏览器界面,解析 HTML,CSS,构建 DOM 树和 RenderObject 树,布局和绘制等。
JS 引擎线程：javascript 引擎,也称为 JS 内核,负责处理 Javascript 脚本程序（v8引擎）

这个引擎(V8)主要由两部分组成:
内存堆：这是内存分配发生的地方
调用栈：这是你的代码执行时的地方
GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。


在 JavaScript 运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。
通常这个栈被称为调用栈 Call Stack ，或者执行栈（ Execution Context Stack ）。
调用栈：顾名思义是具有LIFO(后进先出,Last in First Out)的结构。调用栈内存放的是代码执行期间的所有执行上下文
执行上下文中：都会有三个重要的属性 this、变量对象(VO)和作用域链([[scope]])
# 消息（任务）队列
分为宏任务和微任务

# 事件循环Event Loop是监听并执行消息队列中的任务。 js实现异步的一种方法,也是js的执行机制：：：：：：：：：：：：：
外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->
定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段..

# 事件循环的具体流程如下：
从宏任务队列中，按照 入队顺序 ，找到第一个执行的宏任务，放入调用栈，开始执行；
执行完 该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，
直至微任务队列清空为止 ；当微任务队列清空后，一个事件循环结束；
接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

# 在线调试地址：https://www.jsv9000.app/
macro-task(宏任务)：包括整体代码script,setTimeout,setInterval
micro-task(微任务)：Promise, process.nextTick(Node环境)

# async await
异步代码 同步执行
async函数表示函数里面可能会有异步方法,await后面跟一个表达式,async方法执行时,遇到await会立即执行表达式
然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行


eg:  6之后执行8  是因为 6是第一个微服务 执行完微服务要执行所有的微服务
eg: 2，4 ，3，5,,24之后要执行完这里的微服务再执行下面的微服务。下面的setimeOut是第三轮的事件循环宏服务
 🌰 🌰 🌰 🌰 🌰 🌰 🌰
 setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

 🌰 🌰 🌰 🌰 🌰 🌰 🌰 🌰 1  7 6 8 2 4 3 5 9  10 11 12
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

process.nextTick(function() {
    console.log('6');
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

; web worker！！！！！！！！！！！！！！！！！！！！！ demo https://github.com/xy-sea/blog/tree/main/web-worker
; 因为js是单线程 当js有大量计算时，会造成 UI 阻塞，出现界面卡顿、掉帧等情况，严重时会出现页面卡死的情况，俗称假死
1：开启多线程,并行计算
2:web worker除了单纯进行计算外，还可以结合离屏canvas进行绘图，提升绘图的渲染性能和使用体验

; Web Worker的限制
1、在 Worker 线程的运行环境中没有 window 全局对象，也无法访问 DOM 对象
2、Worker中只能获取到部分浏览器提供的 API，如定时器、navigator、location、XMLHttpRequest等
3、由于可以获取XMLHttpRequest 对象，可以在 Worker 线程中执行ajax请求
4、每个线程运行在完全独立的环境中，需要通过postMessage、 message事件机制来实现的线程之间的通信


# iframe的缺点
1.会产生很多页面，不容易管理。
3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。




# 浏览器搜索引擎的原理
1网页抓取（Crawling）：搜索引擎使用称为"蜘蛛"或"爬虫"的程序来抓取互联网上的网页。这些爬虫按照预定的算法和规则，从一个页面到另一个页面，通过链接不断地抓取网页内容。
2网页索引（Indexing）：抓取到的网页内容被存储在搜索引擎的数据库中，形成一个索引。索引是一个巨大的、结构化的数据集，其中包含了抓取到的网页的关键信息，如页面标题、URL、关键字、内容摘要等。
3查询处理（Query Processing）：当用户在浏览器中输入搜索关键字，浏览器将查询关键字发送到搜索引擎服务器。搜索引擎服务器接收到查询后，会进行查询处理，将查询关键字与索引中的网页进行匹配。
4排名算法（Ranking Algorithm）：搜索引擎使用排名算法对匹配的网页进行排序，以确定搜索结果的排名顺序。排名算法考虑多个因素，如关键字的相关性、网页的质量、页面链接的权威性等。
5结果呈现（Result Presentation）：排名确定后，搜索引擎将搜索结果返回给用户。搜索结果通常以页面的形式呈现，显示与查询关键字相关的标题、URL和摘要等信息。用户可以点击搜索结果来访问相应的网页。

# SEO优化
说白了就是使得自己的网站对于搜索引擎的爬虫更加友好，目前单页面应用的大部分做法是使用前端框架，导致主页面没有相关的描述信息，详细信息大部分都是动态生成的，
对于爬虫来说去准确模拟相关的行为获取符合数据是很困难的（对于如此大规模的数据来说）


### SEO优化的优点
可以提高网站在搜索引擎结果页面中的排名和可见性，从而吸引更多的有针对性的流量


# SPA优点
1 切换应用会更加流畅,用户体验好
2 不需要记载整个页面。良好前后端分离
3 切换组件通过发ajax请求资源,服务端不进行渲染,服务端压力小


# SPA单页面应用（Single Page Application，SPA）由于其特殊的前端技术实现方式,可能会导致一些与搜索引擎优化（SEO）相关的问题。以下是一些常见的原因：
1 缺乏静态HTML：传统的多页面应用通常在每个页面上都有独立的HTML内容,而SPA通常只有一个HTML文件。这意味着搜索引擎爬虫无法直接获取到每个页面的静态HTML内容,
从而影响了搜索引擎对网站内容的理解和索引。
2 动态加载内容：SPA通常使用JavaScript来动态加载内容,这意味着页面的内容可能在初始加载时并不完整。搜索引擎爬虫在抓取页面时可能无法执行JavaScript代码,导致无法获取到完整的页面内容。
3 URL结构：SPA通常使用URL的片段标识符(井字符)或者HTML5的历史记录API来实现页面切换,这样的URL结构对搜索引擎来说可能不够友好。搜索引擎更喜欢静态的、有意义的URL，而不是包含特殊字符或片段标识符的URL。
4 缺乏元数据：SPA通常在初始加载时只返回基本的HTML结构,而不包含完整的元数据（如标题、描述、关键词等）。这使得搜索引擎难以理解页面的内容和关联性。


# 改善SPA的SEO
1 预渲染：使用预渲染技术,将SPA的页面在服务器端提前渲染成静态HTML,并将其提供给搜索引擎爬虫。这样可以确保搜索引擎能够获取到完整的页面内容。
2 使用合适的URL结构：尽量使用静态、有意义的URL结构,避免使用片段标识符或特殊字符。
3 提供元数据：在初始加载时，确保页面包含完整的元数据，包括标题、描述、关键词等，以便搜索引擎理解页面的内容。
4 使用合适的链接和导航：确保SPA中的链接和导航可以被搜索引擎爬虫正确解析和跟踪,以便搜索引擎能够索引到所有的页面。


## Nuxt
2023-11-09-08-53-00.png

# SSR
2023-11-09-09-08-22.png



# 前端模块化：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
window----IIFE-------AMD-------CMD--------CommonJs-------UMD(同时兼容了amd cmd common.js的规范)---------ESM

异步模块定义规范(AMD)制定了定义模块的规则,这样模块和模块的依赖可以被异步加载。
这和浏览器的异步加载模块的环境刚好适应(浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题)
AMD 是一种异步模块规范,RequireJS 是 AMD 规范的实现

1：IIFE 创建自执行函数
var testUtils = function () {
    function test(data){
        console.log(data)
    }
    return {
      test
    }
}()


：AMD（RequireJS）
 依赖必须一开始就写好
define(['./utils'], function(utils) {
  utils.request();
});

// CMD----跟requireJS解决同样问题，只是运行机制不同。
define(function(require) {
  依赖可以就近书写
  var utils = require('./utils');
  utils.request();
});

：CommonJS
随着 node 诞生，服务器端的模块规范 CommonJS 被创建出来。
var config = require('./config');
const {
    notExistFold,
    prompt,
} = require('./util.js');

module.exports = NAME
exports = NAME

：UMD
amd cmd 通常只能在浏览器中使用, commonjs只能在服务端(Node)**环境下使用

(function (root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        // commonjs
        module.exports = factory()
    else if (typeof define === 'function' && define.amd)
        // amd、cmd
        define([], factory)
    else if (typeof exports === 'object')
        // commonjs
        exports['math'] = factory()
    else
        // 全局对象, 浏览器中是 window
        root['math'] = factory()
})(this, function() {
    return { add: function(left, right) { return left + right; } }



：ES6 module：(目前的浏览器还没有全部兼容 需要使用bable进行处理)
import api from './config.js';
import { api as myApi } from './config.js';

export const prefix = 'https://github.com';
export default function foo() {}

ES6 module 使用import导入模块接口
import { api as myApi } from './config.js';
import()实现按需加载

##  对比差异
// Named export/import  具名导出/导入:
export { sum }   
import { sum } from 'sum'  

// Default export/import  默认导出/导入:
export default sum   
import sum from 'sum'

exports 仅仅是 module.exports 的引用
// 实际上的 exports
exports = module.exports

本质是导出exports对象{}

## CommonJS与ES6 Module最本质的区别是：动态vs静态

CommonJS对模块依赖的解决是“动态的”（只能在运行时，分析出对应的依赖关系）
ES6 Module是“静态的”（可以在编译时，就分析出对应的依赖关系，才能做tree shaking）

require的模块路径可以动态指定，支持传入一个表达式，我们甚至可以通过if语句判断是否加载某个模块。
因此，在CommonJS模块被执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

对于CommonJS来说获取的是一份导出值的拷贝；
而在ES6 Module中则是值的动态映射，并且这个映射是只读的。

# 什么是COS?
COS,全称对象存储(Cloud Object Storage),COS是一种存储海量文件的分布式存储服务,
它能让用户可通过网络随时存储和查看数据。通常我们公司的图床、前端静态资源存储都会用到COS,
它能够做到让我们的静态资源摆脱对单个服务器的依赖


# CDN是什么::::::::::::::::::::::::::::::::::::::::::::::::::::::
CDN 全称 Content Delivery Network,即内容分发网络,它是在现有网络结构中增加一层遍布全球的高性能加速节点构成新的虚拟网络架构
其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

CDN 的工作原理:就是将源站的资源缓存CDN各个节点上,当请求命中了某个节点的资源缓存时，立即返回客户端，
避免每个请求的资源都通过源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验
🌰🌰举一个生活中的例子，我们在某东上购买商品，快递能做到当日送达，其根本原理是通过在全国各地建设本地仓库。当用户购买商品时，通过智能仓配模式，为消费者选择就近仓库发货，从而缩短物流配送时间

../note/sublime/assets/note2023-12-26-08-44-43.png




# 扩展 webRtc：：：：Real Time Communications

webSocket 如何兼容低浏览器？

Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于 multipart 编码发送 XHR 、
基于长轮询的 XHR。



