# canvas svg 区别：：：：：；：：：
1：Canvas是基于像素的位图，而SVG却是基于矢量图形
2：从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。
3：Canvas是基于HTML canvas标签，通过宿主提供的Javascript API对整个画布进行操作的，而SVG则是基于XML元素的。
4：svg可以直接嵌入html代码 

！！如果你绘制出来的图像是扭曲的，尝试用 width 和 height 属性为<canvas>明确规定宽高，而不是使用 CSS。


1:var ctx = canvas.getContext('2d');
2:var myGradient = ctx.createLinearGradient(0, 0, 0, 160); createLinearGradient方法用来设置渐变色。

// ctx.arc(x,y,r,sAngle,eAngle,counterclockwise)

// fillRect(x, y, width, height) 绘制一个填充的矩形
// strokeRect(x, y, width, height)绘制一个矩形的边框
// clearRect(x, y, widh, height)清除指定的矩形区域，然后这块区域会变的完全透明。
// beginPath()新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径
// moveTo(x, y)把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。
// closePath()闭合路径之后，图形绘制命令又重新指向到上下文中
// stroke()通过线条来绘制图形轮廓
// fill()通过填充路径的内容区域生成实心的图形
// 绘制圆弧：：
// arc(x, y, r, startAngle, endAngle, anticlockwise):
// 以(x, y)为圆心，以r为半径，从 startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针。(默认是顺时针)
// radians=(Math.PI/180)*degrees   //角度转换成弧度
// arcTo(x1, y1, x2, y2, radius):根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。

//  ctx.drawImage(img, 10, 10);
// 参数	描述
// img	规定要使用的图像、画布或视频。
// sx	可选。开始剪切的 x 坐标位置。
// sy	可选。开始剪切的 y 坐标位置。
// swidth	可选。被剪切图像的宽度。
// sheight	可选。被剪切图像的高度。
// x	在画布上放置图像的 x 坐标位置。
// y	在画布上放置图像的 y 坐标位置。
// width	可选。要使用的图像的宽度（伸展或缩小图像）。
// height	可选。要使用的图像的高度（伸展或缩小图像）。

组件库：Konva
konva 是一个对 canvas API 做了封装增强的 JavaScript 库。
HTML 原生的 canva 提供的 API 比较底层，用法上像是操纵一支画笔进行各种操作，画完就结束了。
canvas 本身不维护图形树，你也无法操作修改已被绘制的图形。
而 konva 能够像我们操作 DOM 树一样去绘制和维护元素，它会额外维护图形构成的树，并能在绘制后，对特定图形进行样式的修改。
你还可以在上面添加事件，比如鼠标滑入某图形时，图形变大一点。此外还支持方便的变形、动画、拖拽等高级能力。


svg:


<svg> 包裹并定义整个矢量图。<svg> 标签之于矢量图就如同 <html> 标签之于一个 web 页面。
<line> 创建一条直线。
<polyline> 创建折线。
<rect> 创建矩形。
<ellipse> 创建圆和椭圆。

<polygon> 创建多边形。
现在我们来创建多边形。我们将会放置三个点，这些点之间会自动生成线段来创建一个三角形。点将是 (35,23)，(60,43) 和 (35,63)。如此，我们的多边形代码将会是：
<polygon points="35 23, 60 43, 35 63" />

<path> 通过指定点以及点和点之间的线来创建任意形状。

M 表示移动到（moveto）。它用 x 值和 y 值来给定一条新的路径的起始点。可以想象成把你的鼠标放在画布上的某一点以准备开始绘画。大写的 M 表示移动到一个绝对坐标集合（小写的 m 表示移动到一个相对坐标集合）。
L 表示划线到（lineto）。从当前位置到新的位置画一条线。大写的 L 表示移动到一个绝对坐标集合（小写的 l 表示移动到一个相对坐标集合）。
Z 表示闭合路径。通过在当前点和路径的起始点之间画一条直线来闭合形状。



<defs> 定义一个可复用的图形。初始情况下 <defs> 里面的内容是不可见的。<defs> 标签之于矢量图就如同 <head> 标签之于一个 web 页面。
<g> 将多种形状组合起来。将组合后的形状置于 <defs> 中可以让它能够被复用。
<symbol> 类似于一个组合，但是拥有一些额外的特性。通常被置于 <defs> 标签中便于复用。
<use> 获取在 <defs> 中定义的复用对象并在 SVG 中显示出来。


https://codepen.io/anthonydugois/pen/mewdyZ

https://jxnblk.github.io/paths/?d=M40%2032%20L32%2024%20L32%2010%20L16%2010%20L16%2024%20L8%2032%20Z




### waapi：Web Animation API 动画




## 包管理
## pnpm： https://zhuanlan.zhihu.com/p/457698236

npm install -g pnpm

配置环境变量：

http://106.12.154.161/images/huan1.png

http://106.12.154.161/images/huan2.png


pnpm up --latest


命令：
pnpm install
pnpm add name
pnpm add -D name


# 问题 pnpm: ENOENT: no such file or directory, 
stat 'D:\VUE2-TS\rt-ued-scaffolding\node_modules\.pnpm\@types+react@17.0.47\node_modules\csstype'


#
pnpm add -g pnpm

surcode@surcodedeMacBook-Pro ~ % pnpm setup      
Created /Users/surcode/.zshrc

Next configuration changes were made:
export PNPM_HOME="/Users/surcode/Library/pnpm"
export PATH="$PNPM_HOME:$PATH"

To start using pnpm, run:
source /Users/surcode/.zshrc
surcode@surcodedeMacBook-Pro ~ % source /Users/surcode/.zshrc
surcode@surcodedeMacBook-Pro ~ % pnpm add -g pnpm  


<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2187b2c861fd4b469203ff222364ebd9~tplv-k3u1fbpfcp-watermark.image" alt=""  width="50%" />

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2187b2c861fd4b469203ff222364ebd9~tplv-k3u1fbpfcp-watermark.image" alt=""  width="49%" />




更新项目依赖包： https://www.npmjs.com/package/npm-check-updates

npm-check-updates

更新包  ncu -u


# upgrade only mocha
ncu mocha
ncu -f mocha
ncu --filter mocha

# upgrade packages that start with "react-"
ncu react-*
ncu "/^react-.*$/"

# upgrade everything except nodemon
ncu \!nodemon
ncu -x nodemon
ncu --reject nodemon

# upgrade only chalk, mocha, and react
ncu chalk mocha react
ncu chalk, mocha, react
ncu -f "chalk mocha react"

# upgrade packages that do not start with "react-".
ncu \!react-*
ncu '/^(?!react-).*$/' # mac/linux
ncu "/^(?!react-).*$/" # windows






yarn：

npm：

cnpm：






{/* <Uploader
						value={[
							{
								status: 'failed',
								name: 'leaf',
								url: 'https://img17.fn-mart.com/pic/2a021346939822ebb66f/B26n221z_2fdhMZdKz/7imyeafa3yKGj9/CsmRtmA3RAuAVmgsAAKtgt1PF3s715.jpg',
							},
						]}
						showFileList={false}
					/> */}



<Form.Item name="uploader">
						<Uploader
							multiple={true}
							onRead={(fileList) => {
								if (fileList.length > 5) {
									Toast.fail(`最多只能传5个`);
									return [];
								}

								return fileList.map((file) => ({
									...file,
									status: 'done',
								}));
							}}
							// className={}
							// style={{ top: '60px' }}
							// onChange={(v) => setUploaderData('uploadStatus', v)}
							// onUpload={handleUploadChange}
							onUpload={handleUpload}
							onChange={handleUploadChange}
							slots={{
								filePreviewCover: ({ file }) => {
									console.log(file, 'file-----888	');
									return (
										<div
											style={{
												height: '100%',
												display: 'flex',
												justifyContent: 'center',
												alignItems: 'center',
											}}
										>
											{/* <Circle progress={progress} style={{ width: '100%', height: '100%' }}>
												<div style={{ color: '#1989fa' }}>{progress}%</div>
											</Circle> */}

											{/* //! 接口一直延迟怎么办 */}
											{/* {progress !== 100 && ( // && successFileRef.current.includes(file?.name)
												<div>
													<Icon.Spinner color="#358afa" />
													<div style={{ color: '#1989fa' }}>{progress}%</div>
												</div>
											)} */}
											{!failedFlag && (
												<div>
													<Icon.Spinner color="#358afa" />
													<div style={{ color: '#1989fa' }}>上传中</div>
												</div>
											)}
											{/* {!failedFlag.includes(file?.name) && (
												<div>
													<Icon.Spinner color="#358afa" />
													<div style={{ color: '#1989fa' }}>{progress}%</div>
												</div>
											)} */}
											<div className={bem('preview-cover')}>
												{failedFlag && successFileList.includes(file?.name) && (
													<div style={{ color: 'red', fontWeight: 'bold' }}>
														<Icon name="fail" color="#ee0a24" />
													</div>
												)}
												{file && file.name}
											</div>
											{/* failed不是最后出来  */}
										</div>
									);
								},
							}}
						>
							<Button icon={<Icon name="plus" />} type="primary" plain>
								添加附加
							</Button>
						</Uploader>
					</Form.Item>