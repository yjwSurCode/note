
时间复杂度：https://juejin.cn/post/6844904103194132494

衡量代码好坏有两个非常重要的标准就是：运行时间和占用空间，就是我们后面要说到的时间复杂度和空间复杂度，也是学好算法的重要基石

O(1) 表示一次操作即可直接取得目标元素
O(n) 意味着先要一个循环检查 n 个元素来搜索目标
O(n^2) 平方阶 两个嵌套循环检查 n 个元素
O(logn) 对数阶  （ 二分法，将n分成两份）
O(n*logn) 线性对数阶  （将n分成两份外加一个循环）

n=2^k  LOG2N=k


链表（首尾相连的线性的数据结构）：：：：：：：：：：：：：：：：：：：：：：：：：：：：

数组：内存上是连续的存储空间； 
链表：内存地址可以是不连续的，每个链表的节点包括原来的内存和下一节点的信息（单向链表一个；双向链表两个）。
双向链表：每个节点都包含下一个节点和上一个节点的指针，所以从双向链表的任意节点开始，都能很方便访问他的前驱结点和后继节点。


数组优点：   1、占用内存空间少； 2、数组内的数据可以随机访问； 3、数据查找效率较高（内存连续）；
链表优点：   1、方便数据的删除、插入； 2、长度可变，扩展性好； 3、内存利用率高（可以不连续）；


class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = this.head;
    this.length = 0;
  }
  append(value) {
    const newNode = new Node(value);
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }
    this.length++;
  }

  prepend(value) {}

  insert(value, index) {}

  lookup(index) {}

  remove(index) {}

  reverse() {}
}

let linkedList2 = new LinkedList();

linkedList2.append("23");
console.log(linkedList2, "linkedList2");



 

二叉树：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：

二叉树（Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称为「左子树」和「右子树」。二叉树的分支具有左右次序，不能颠倒。

特征:
(1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
(2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
(3) 它的左、右子树也分别为二叉查找树


function BinarySearchTree(keys) {
  //Node构造函数
  let Node = function (key) {
    this.key = key;
    this.left = null;
    this.right = null;
  };

  let root = null;

  let insertNode = (node, newNode) => {
    console.log(
      node,
      newNode,
      "insertNode------node, newNode",
      newNode.key,
      node.key
    );
    if (newNode.key < node.key) {
      if (node.left === null) {
        node.left = newNode;
        console.log(node, "node--left");
      } else {
        insertNode(node.left, newNode);
      }
    } else {
      if (node.right === null) {
        node.right = newNode;
      } else {
        insertNode(node.right, newNode);
      }
    }
  };

  this.insert = (key) => {
    let newNode = new Node(key);
    console.log("newNode", newNode);
    if (root === null) {
      root = newNode;
    } else {
      insertNode(root, newNode);
    }
  };
  keys.forEach((key) => {
    console.log("KEY", key);
    this.insert(key);
  });
  return root;
}
const keys = ["1", "3", "5", "4", "2"];
BinarySearchTree(keys);

console.log(BinarySearchTree(keys), "root");




栈：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：

栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。

引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。

var person1 = {name:'jozo'};     （栈区）(person1---堆内存地址1)-----》object1(堆区)


js 深拷贝vs浅拷贝：：：：：：：：：：：：
注意：
基本数据类型的特点：直接存储在栈(stack)中的数据 ---------------(String, Number, Boolean, Null, Undefined，Symbol)
引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里---------------(Object,Array,function...)

1: var a=1  b=a a=2 ----console.log(b) //1
2： var a = {
        name:'weiwei'
    }; 
    var b = a; // 新建一个b对象，地址指向a指向的堆 --------------引用类型的赋值是传址。只是改变指针的指向
    a.name='ww' console.log(b.name); // 'ww' 

浅拷贝方法：JSON.parse(JSON.stringify())----------------这种方法虽然可以实现数组或对象深拷贝,但不能处理函数

深拷贝方法：
function clone(target, map = new Map()) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {}; //考虑到数组情况了
        //解决循环引用问题
        if (map.get(target)) {
            return map.get(target);
        }
        map.set(target, cloneTarget);

        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        console.log('执行')
        return cloneTarget;

    } else {
        return target;
    }
};

栈（stack）又名堆栈，是一种遵循后进先出（LIFO）原则的有序集合,新添加或待删除的元素都保存在栈的末尾，称作栈顶，另一端称作栈底


function Stack() {
  this.dataStore = []; //初始化为空
  this.top = 0; //记录栈顶位置
  this.pop = pop; //出栈
  this.push = push; //入栈
  this.peek = peek; //查看栈顶元素
  this.length = length; //查看栈内元素总数
  this.clear = clear; //清空栈

  function push(element) {
    this.dataStore[this.top++] = element;
  }

  //取出栈顶元素
  function pop() {
    return this.dataStore[--this.top];
  }

  function peek() {
    if (this.top > 0) return this.dataStore[this.top - 1];
    else return "Empty";
  }

  function clear() {
    delete this.dataStore;
    this.dataStore = [];
    this.top = 0;
  }

  function length() {
    return this.top;
  }
}

var stack = new Stack();
console.log(stack.peek());
stack.push("111");
console.log(stack.peek());

回文判断：：：：：：：：：：：：：：：：：：：：：：：：：：
function isPalindrome(word) {
  var s = new Stack();
  for (var i = 0; i < word.length; i++) {
    s.push(word[i]);
  }

  var rword = "";

  while (s.length() > 0) {
    // rword += s.pop();
    rword = s.pop() + rword;
  }

  if (word === rword) {
    return true;
  } else {
    return false;
  }
}
console.log(isPalindrome("level")); // true


队列：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表
队列是一种先进先出的线性表,简称FIFO-------允许插入的一端称为队尾(Rear)允许删除的一端称为队头(Front)。


浏览器执行顺序：执行栈在执行完同步任务之后，如果执行栈为空，
就会去检查微任务（MicroTask）队列是否为空------------如果为空的话,就会去执行宏任务队列（MacroTask）
                                      --------------如果不为空的话,就会一次性执行完所有的微任务队列


扁平数据结构转tree：https://juejin.cn/post/6983904373508145189
