1:ref

2:reactive

3:computed

4:slot



忽略.vue后缀
export default defineConfig({
  resolve: {
    extensions: ['.js', '.ts', '.jsx', '.tsx', '.json', '.vue']
  }
})





参考链接：https://juejin.cn/post/6986838175062687752	







// class Dep {
//   // 订阅池
//   constructor(name) {
//     this.id = new Date(); //这里简单的运用时间戳做订阅池的ID
//     this.subs = []; //该事件下被订阅对象的集合
//   }
//   defined() {
//     // 添加订阅者
//     Dep.watch.add(this);
//   }
//   notify() {
//     //通知订阅者有变化
//     this.subs.forEach((e, i) => {
//       if (typeof e.update === "function") {
//         try {
//           e.update.apply(e); //触发订阅者更新函数
//         } catch (err) {
//           console.warr(err);
//         }
//       }
//     });
//   }
// }
// Dep.watch = null;

// class Watch {
//   constructor(name, fn) {
//     this.name = name; //订阅消息的名称
//     this.id = new Date(); //这里简单的运用时间戳做订阅者的ID
//     this.callBack = fn; //订阅消息发送改变时->订阅者执行的回调函数
//   }
//   add(dep) {
//     //将订阅者放入dep订阅池
//     dep.subs.push(this);
//   }
//   update() {
//     //将订阅者更新方法
//     var cb = this.callBack; //赋值为了不改变函数内调用的this
//     cb(this.name);
//   }
// }
// var addHistoryMethod = (function () {
//   var historyDep = new Dep();
//   return function (name) {
//     if (name === "historychange") {
//       return function (name, fn) {
//         var event = new Watch(name, fn);
//         Dep.watch = event;
//         historyDep.defined();
//         Dep.watch = null; //置空供下一个订阅者使用
//       };
//     } else if (name === "pushState" || name === "replaceState") {
//       var method = history[name];
//       return function () {
//         method.apply(history, arguments);
//         historyDep.notify();
//       };
//     }
//   };
// })();

// window.addHistoryListener = addHistoryMethod("historychange");
// history.pushState = addHistoryMethod("pushState");
// history.replaceState = addHistoryMethod("replaceState");






v-modal 发布者 订阅者
Object.defindProperty

observer.js 数据劫持  geter seter
compile.js 判断元素  添加监听数据的订阅者 数据变化 更新试图
watcher 订阅者 oserver compile之间通信的桥梁
mvvm
数据绑定的入口 整合三者 通过observer监听modal数据的变化 通过compile来解析编译模板的指令 watcher 数据变化----》视图更新----》视图交互变化