
忽略.vue后缀
export default defineConfig({     // vite umi??
  resolve: {
    extensions: ['.js', '.ts', '.jsx', '.tsx', '.json', '.vue']
  }
})

参考链接：https://juejin.cn/post/6986838175062687752	


// class Dep {
//   // 订阅池
//   constructor(name) {
//     this.id = new Date(); //这里简单的运用时间戳做订阅池的ID
//     this.subs = []; //该事件下被订阅对象的集合
//   }
//   defined() {
//     // 添加订阅者
//     Dep.watch.add(this);
//   }
//   notify() {
//     //通知订阅者有变化
//     this.subs.forEach((e, i) => {
//       if (typeof e.update === "function") {
//         try {
//           e.update.apply(e); //触发订阅者更新函数
//         } catch (err) {
//           console.warr(err);
//         }
//       }
//     });
//   }
// }
// Dep.watch = null;

// class Watch {
//   constructor(name, fn) {
//     this.name = name; //订阅消息的名称
//     this.id = new Date(); //这里简单的运用时间戳做订阅者的ID
//     this.callBack = fn; //订阅消息发送改变时->订阅者执行的回调函数
//   }
//   add(dep) {
//     //将订阅者放入dep订阅池
//     dep.subs.push(this);
//   }
//   update() {
//     //将订阅者更新方法
//     var cb = this.callBack; //赋值为了不改变函数内调用的this
//     cb(this.name);
//   }
// }
// var addHistoryMethod = (function () {
//   var historyDep = new Dep();
//   return function (name) {
//     if (name === "historychange") {
//       return function (name, fn) {
//         var event = new Watch(name, fn);
//         Dep.watch = event;
//         historyDep.defined();
//         Dep.watch = null; //置空供下一个订阅者使用
//       };
//     } else if (name === "pushState" || name === "replaceState") {
//       var method = history[name];
//       return function () {
//         method.apply(history, arguments);
//         historyDep.notify();
//       };
//     }
//   };
// })();

// window.addHistoryListener = addHistoryMethod("historychange");
// history.pushState = addHistoryMethod("pushState");
// history.replaceState = addHistoryMethod("replaceState");


6:v2.x 与 vue3.0之间的区别:
基于 Proxy 观察者机制以满足全语言覆盖以及更好的性能；
放弃 Object.defineProperty ，使用更快的原生Proxy；
beforeCreate -> 请使用 setup()
created -> 请使用 setup()
beforeMount -> onBeforeMount
mounted -> onMounted
beforeUpdate -> onBeforeUpdate
updated -> onUpdated
beforeDestroy -> onBeforeUnmount
destroyed -> onUnmounted


v-modal 发布者 订阅者 ：：：：：：：：：：：：：：：：：：：：：
Object.defindProperty
observer.js 数据劫持  geter seter
compile.js 判断元素  添加监听数据的订阅者 数据变化 更新试图
watcher 订阅者 oserver compile之间通信的桥梁
mvvm
数据绑定的入口 整合三者 通过observer监听modal数据的变化 通过compile来解析编译模板的指令 watcher 数据变化----》视图更新----》视图交互变化

Object.defindProperty对比proxy：：：：：：：：：：：：：：：：：：：：：：：  (https://juejin.cn/post/6844904150560423950)
1:不需要递归遍历每个属性，添加劫持，深层对象属性只有在访问的时候才转换成 Proxy
2:对新增的属性不需要另外做劫持处理
3:不需要对数组的方法进行重定义
缺点：不兼容 ie



setup() {
        const { proxy } = getCurrentInstance();
        onMounted(() => {
            proxy.$toast.loading({
                message: '加载中...',
                forbidClick: true,
            })
        });
 
        return {};
    }


Vue3新特性:：：：：：：：：：：：：：：：：：：：：：：

vue3通过10个实例小练习https://github.com/biaochenxuying/blog/issues/63

vben的vue3源码 :https://github1s.com/anncwb/vue-vben-admin

vue3源码：https://github1s.com/vuejs/core/blob/HEAD/packages/reactivity/src/computed.ts

Proxy为什么要配合Reflect使用：https://juejin.cn/post/7080916820353351688



// import { nextTick } from 'vue'

// <template>
//     <div v-if >
//         优先级提升比v-for大
//     </div>
//     <input type="text" name="" id="" v-focus></input>
// </template>
// export default {
//     components: {
//         Testd,
//         Testdd,
//     },
//     props: {
//         msg: String,
//         propsMsg: "propsMsg",
//     },
//     directives: {
//         focus: {
//             // 参数 el, binding, vnode, oldVnode
//             mounted: function (el) {
//                 el.focus()
//             }
//         }
//     },
//     setup(props) {
//         const repositories = ref < string | null > ([]) // 定义一个变量
//         repositories.value = newContent;
//         const getUserRepositories = async () => { // 定义一个方法
//             await api()
//         }
//         const img = computed(() => {
//             return (props.type && IMG.get(props.type)) || defaultImg;
//         });
//         const stated = reactive({ allPageLength: 0, moreText: "加载更多" });
//         onMounted(() => {
//             getUserRepositories,// 生命周期钩子 当实例mounted后调用getUserRepositories方法
//                 nextTick(() => {
// ----------------------------------一些和DOM有关的东西
//                 })
//         })
//         return {
//             img,
//             repositories, // 返回一个data
//             ...toRefs(stated),
//             getUserRepositories // 返回一个method
//         }
//     }
// }


computed watch 区别：：：：：：：：：：
computed  是计算属性,依赖其它属性值，并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed  的值；
watch 更多的是「观察」的作用,类似于某些数据的监听回调 ,每当监听的数据变化时都会执行回调进行后续操作；


// 异步组件
// const AsyncCategory = defineAsyncComponent(() => import("./AsyncCategory.vue"))

//   import Loading from './Loading.vue';

//   const AsyncCategory = defineAsyncComponent({
//     loader: () => import("./AsyncCategory.vue"),
//     loadingComponent: Loading,  占位组件，当AsyncCategory还没加载出来时候，显示这个组件
//     errorComponent: 当AsyncCategory加载失败出现
//     delay: 2000, 在显示loadingComponent组件之前, 等待多长时间
//     /**
//      * err: 错误信息,
//      * retry: 函数, 调用retry尝试重新加载
//      * attempts: 记录尝试的次数
//      */
//     onError: function(err, retry, attempts) {
//     }
//   })



//内置组件  defalult可以显示 不可以显示就显示fallback
// < suspense >
{/* <template #default>
    <async-category></async-category>
  </template>
  <template #fallback>
    <loading></loading>
  </template>
</ > */}

state：包含了store中存储的各个状态。
getter: 类似于 Vue 中的计算属性，根据其他 getter 或 state 计算返回值。
mutation: 一组方法，是改变store中状态的执行者，只能是：同步：操作。
action: 一组方法，其中可以包含异步操作。：：：

store.commit('increment')

想要异步地更改状态，就需要使用action。action并不直接改变state，而是发起mutation。
actions: {
    increment (context) {
      context.commit('increment')
    }
  }



浅析vue-cli脚手架@vue/cli-service源码：：：：：：：：：：：：：：：：：：

vue-cli使用指南：https://cli.vuejs.org/zh/dev-guide/plugin-dev.html

vue create vue-cli-app ------ vue-cli-service build

使用npm run script 命令时，直接会找到node_modules/.bin下面对应的脚本，windows系统对应vue-cli-service.cmd命令，类unix系统是/bin/sh命令
开始执行vue-cli-service.js
Service实例化后，又到vue-cli-service.js中，执行service run方法
config 下的base.js css.js 等webpack配置模块都会执行chainWebpack方法，以base模块为例
build方法会根据命令行参数，加载不同的模块来处理webpack配置

