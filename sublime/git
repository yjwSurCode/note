# 原理：git ls-files --stage
index文件git暂存区存放index文件中，所以我们把暂存区有时也叫作索引（index）。
索引是一个二进制格式的文件，里面存放了与当前暂存内容相关的信息，包括暂存的文件名、文件内容的SHA1哈希串值和文件访问权限。
暂存区是贯穿于整个Git使用流程的重要概念，所以index文件就很重要。由于是二进制所以我们无法查看具体内容，
但是可以用git ls-files --stage 命令查看暂存区里面的文件

# objects目录
Git对象(blob,tree,commit,tag)都保存在objects目录里面，
所以objects目录就是真正的仓库。objects里面的目录结构组织的很有特点，是以SHA值的前2位作为目录，后38位作为这个目录下的文件名。

# Tree 对象
一个tree对象有一串(bunch)指向blob对象或是其它tree对象的指针，它一般用来表示内容之间的目录层次关系。
git ls-tree 或 git cat-file -p 命令还可以用来查看tree对象，现在我们查看刚刚最新提交对应的Tree对象 我们可以像下面一样来查看它：

# 将本地仓库与远程仓库建立联系 git remote add origin 项目地址
从命令的角度来看，git add 可以分两条底层命令实现:
git hash-object<file>
git update-index --add<file>

# 查看远程地址 
git remote -v

HEAD：当前提交你的回购。大多数时候都  HEAD 指向分支中的最新提交，但情况并非如此。 HEAD 真的只是意味着“我的回购目前指向的是什么”。
master：git在首次创建repo时为您创建的默认分支的名称。在大多数情况下，“主”意味着“主要分支”。大多数商店都有人推动掌握，而主人被认为是回购的最终观点。但是发布分支也很常见，因为发布分支是由master发布的。您的本地仓库有自己的主分支，几乎总是跟随远程仓库的主人。
origin：git为主远程仓库提供的默认名称。你的盒子有自己的仓库，你最有可能推出一些你和你的同事所推动的远程仓库。这个远程仓库几乎总是被称为原产地，但并非必须如此。


git push origin master
解决办法：强行让本地分支覆盖远程分支git push origin master -f

git push的一般形式为 git push <远程主机名> <本地分支名>  <远程分支名>  eg:git push origin master：refs/for/master 
1.1 git push origin master
如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建
1.2 git push origin ：refs /for/master 
如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin--delete master
git stash save '备注信息'
贮藏修改，就要用到git stash.网址：https://git-scm.com/docs/git-stash
先git stash，本地工作区备分，放入git栈中。然后，工作区内容恢复到仓库head最后一次提交的内容。
然后git pull.
最后，git stash pop,这个过程自动合并。如果成功，则自动此备分从git stash中删除。如果有冲突，则你需要手动解决冲突。然后git stash drop

问题:不建议在没有为偏离分支指定合并策略时执行pull操作
原文链接：https://blog.csdn.net/wq6ylg08/article/details/114106272

git cherry-pick可以选择某一个分支中的一个或几个commit(s)来进行操作。
例如，假设我们有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个v3.0中的功能到v2.0中，这里就可以使用cherry-pick了。

# 查看commit： git log
commit 150f539d430015ba682a3dd95d4f68937eb6533b
Author: 贾季帮 <1424800753@qq.com>
Date:   Mon Jul 5 15:22:26 2021 +0800

git show  150f539d430015ba682a3dd95d4f68937eb6533b

# 如何撤销 git commit

git reset  HEAD~1   回到上一次commit

git reset--soft HEAD~2   撤销两次 可以包括commit push

# Git撤销对远程仓库的push & commit提交::!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
1：执行 git log查看日志, 获取需要回退的版本号
commit 986 a582b88f7c8a9830a916f09d48f476ea84265
Author: Rockcookies < hqy321 @gmail.com >
    Date: Fri Oct 22 20: 29: 36 2021 + 0800

2：执行 git reset -- soft < 版本号>  如：git reset --soft  c59c91158d6b08fc457032073eb26a8d00228b48 重置至指定版本的提交， 达到撤销提交的目的 !!!!!!!!!!!!!!!!

然后执行 git log 查看 此时， 已重置至指定版本的提交， log中已经没有了需要撤销的提交

git reset 命令分为两种： git reset -- soft 与 git reset  -- hard 
区别是：前者表示只是改变了HEAD的指向,本地代码不会变化， 我们使用git status依然可以看到,同时也可以git commit提交,后者直接回改变本地源码,不仅仅指向变化了,代码也回到了那个版本时的代码。

3：执行 git push origin 分支名  -- force， 强制提交当前版本号。 !!!!!!!!!!
exeample: git push origin master --force


git reset--soft HEAD~2    去上一个版本

git revert ec5be  回滚

使用 git revert -n 版本号 反做并使用“git commit -m 版本名”提交：


提交中间的某一次commit


# 撤销 git pull
1: git reflog
2: git reset --hard 6ca3754  

#STASH stash
git stash暂存修改  
git stash list
常用git stash命令：
（1）git stash save "save message"  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。
（2）git stash list  ：查看stash了哪些存储
（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}
（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p
（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} 
（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}
（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储
（8）git stash clear ：删除所有缓存的stash


#更改分支名称
git branch -m oldName newName

# 创建本地分支
git checkout -b 新分支名

提交：git push --set-upstream origin 新分支名称

# 创建远程分支
git checkout -b 新分支名

!!!!!推送
git push origin master-preview:master-preview

删除本地分支：git branch -d 分支名  (不能删除当前所在分支)

删除远程分支
git push origin --delete 分支名

example： 


查看本地和远程分支：git branch -a
查看远程分支 git branch -r

git rebase -i  HEAD~3
git rebase --abort 会放弃合并，回到rebase操作之前的状态，之前的提交的不会丢弃；
git rebase --skip 则会将引起冲突的commits丢弃掉（慎用！！）；
git rebase --continue 合并冲突，结合"git add 文件"命令一起用与修复冲突，提示开发者，一步一步地有没有解决冲突。（fix conflicts and then run “git rebase --continue”）

git pull --rebase      不会产生新的节点
不带任何选项的git pull命令：先尝试快进合并，如果不行再进行正常合并生成一个新的提交。
git pull --ff-only命令：只尝试快进合并，如果不行则终止当前合并操作。
git pull --no-ff命令：禁止快进合并，即不管能不能快进合并，最后都会进行正常合并生成一个新的提交。
git pull --rebase命令：先尝试快进合并，如果不行再进行变基合并。


问题: error: 您尚未结束您的合并（存在 MERGE_HEAD）。
提示：请在合并前先提交您的修改。
fatal: 因为存在未完成的合并而退出

解决方法:
git merge --abort
git reset --merge

提交指定的commit
https: //blog.csdn.net/u013068502/article/details/85399806?utm_term=%E5%8F%AA%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0%E6%8C%87%E5%AE%9A%E7%9A%84commit&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-85399806&spm=3001.4430




冲突解决：：：：：：：：：：：：：：：

accept current change 保留现在本地最新的

accept incoming change  选择git最新的





// feat： 新增 feature
// fix: 修复 bug
// docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等
// style: 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑
// refactor: 代码重构，没有加新功能或者修复 bug
// perf: 优化相关，比如提升性能、体验
// test: 测试用例，包括单元测试、集成测试等
// chore: 改变构建流程、或者增加依赖库、工具等
// revert: 回滚到上一个版本

// 创建新的分支：git branch gh-dev（分支名字）   
// 删除branch：git branch -d 名称
// git branch -r ，查看远程的分支名   git branch -a
//切换分支 git checkout preview

//  git checkout -b  test master 在master分支上创建一个test分支

// 删除远程分支 Chapater6
// git push origin--delete Chapater6

// 删除本地分支 Chapater6
// git branch -d Chapater6

// 如果您想要为此分支创建跟踪信息，您可以执行：
//git branch --set-upstream-to=origin/<分支> test
// git branch --set-upstream-to=origin/test  test

提交当前分支：
git push --set-upstream origin modesign-project


// git push - u origin dev
// 想将 dev 分支合并到 master 分支，操作如下：
// 1、首先切换到master分支上   
// git checkout master （可以查看一下 git branch）
// 2、如果是多人开发的话 需要把远程master上的代码pull下来
// git pull origin master
//如果是自己一个开发就没有必要了，为了保险期间还是 pull
// 3、然后我们把dev分支的代码合并到master上----就是使master上面的代码和dev上面的代码一样
// git merge dev

// 前提是我现在在master分支上
// git merge dev （这句话的意思就是使现在的master分支和dev分支一样了） (这样 master分支就和dev分支一样了)
// eg: master 分支是主分支  dev分支是次分支 然后合并 流程：在dev分支上执行 git merge master
// 4、然后查看状态及执行提交命令



example:
// 不小心merge怎么办!!!!!!!
// 1: git log
// git reset--hard 01a39de3d84d5bf8139a52def7b02ac1ca67d044
// https://blog.csdn.net/weixin_41282397/article/details/82805313?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control


example:
// fatal: 似乎已有一个 rebase-merge 目录，我怀疑您正处于另外一个变基操作过程中。
// 如果是这样，请执行
//         git rebase (--continue | --abort | --skip)
// 如果不是这样，请执行
//         rm -fr ".git/rebase-merge"
// 然后再重新执行。 为避免丢失重要数据，我已经停止当前操作。


example:
// 您的分支和 'origin/master' 出现了偏离，
// 并且分别有 1 和 1 处不同的提交。
// （使用 "git pull" 来合并远程分支）
// 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：
// git fetch origin
// git reset --hard origin/master

example:
// 问题：您当前不在一个分支上。请指定您要变基到哪一个分支。
// git pull < 远程 > <分支>
// git pull --rebase origin master


example:
// 第一次提交A 第二次提交B   vs code 我push B ，A也会提交上去
// 第一次提交A 第二次提交B   vs code 我push A ，B也就是第二次的不会被提交上去



{
    /* git原理
    https://www.zhihu.com/search?type=content&q=git%20%E5%8E%9F%E7%90%86
    https://zhuanlan.zhihu.com/p/66506485 */
}


## github  CI/CD  自动化持续集成部署代码到服务器

CI - 持续集成（Continuous Integration）
CD - 持续交付 (Continuous Delivery)
CD - 持续部署 (Continuous Deployment)

GitHub Actions 是一个持续集成和持续交付 (CI/CD) 平台，可用于自动执行构建、测试和部署管道。



GitHub Actions 有一些自己的术语。

(1)workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。

(2)job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。

(3)step  (步骤)：每个 job 由多个 step 构成，一步步完成。

(4)action （动作）：每个 step 可以依次执行一个或多个命令(action)


on:
  push:
    branches:    
      - master
上面代码指定，只有master分支发生push事件时，才会触发 workflow。


actions/setup-node@74bc508 # 指向一个 commit
actions/setup-node@v1.0    # 指向一个标签
actions/setup-node@master  # 指向一个分支




# Github上 fork了别人的代码 本地更新主分支代码
在GitHub上我们会去fork别人的一个项目，这就在自己的Github上生成了一个与原作者项目互不影响的副本，自己可以将自己Github上的这个项目再clone到本地进行修改，修改后再push，只有自己Github上的项目会发生改变，而原作者项目并不会受影响，避免了原作者项目被污染。但经过一段时间， 有可能作者原来的代码变化很大， 你想接着在他最新的代码上修改， 这时你需要合并原作者的最新代码过来， 让你的项目变成最新的。
1、先克隆项目到本地：
Git clone https://github.com/iakuf/mojo
cd mojo
2、添加原作者项目的 remote 地址， 然后将代码 fetch 过来
git remote add sri https://github.com/kraih/mojo
git fetch sri
‘sri’相当于一个别名
查看本地项目目录： git remote -v
3、合并
git checkout master
git merge sri/master
如果有冲突的话，需要丢掉本地分支：
git reset –hard sri/master
4、这时你的当前本地的项目变成和原作者的主项目一样了，可以把它提交到你的GitHub库
git commit -am ‘更新到原作者的主分支’
git push origin
git push -u origin master -f –强制提交

http://blog.csdn.net/u013647382/article/details/53400530






## SVN：：：：：：：：：：：：：：https://blog.csdn.net/songxi_bo/article/details/116232203

安装svn 
brew install svn

5、更新文件
svn　update

新建分支branchs，在分支上继续开发
1、svn mkdir branches
2、svn copy svn://server/trunk svn://server/branches/ep -m "init ep"

剪切代码：
svn checkout http://wh-svn.fn.com/feiniu-website/code/ui/branch/project/rt-supplier-openapi

svn add    svn commit -m “提
新建分支：