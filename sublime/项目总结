#鑫青盟官网：https://www.xqmcm.com/#/。 ：：：：：：：：：：：
react ts 类组件 redux  redux-thunk  -----------Redux store 仅支持同步数据流。
使用 thunk 等中间件可以帮助在 Redux 应用中实现异步性。

const mapStateToProps = (state) => ({
  valueS: state
})

<Provider store={ store }>

const store =  createStore(reducers, {     //合并多个 reducer     reducers就是操作数据的方法
    countReducer:initialState,
    countReducer1:initialState1
}, applyMiddleware(thunk));

export  function  mapDispatchToProps(dispath:any){
    return{
               derM:()=> dispath(actions.decrementCount('ni')),
               todoM:()=>dispath(actions.todolistAction(1) )// 在这里定义  就要在 render 里面 实现

    }
}

bar(connect(mapStateToProps, mapDispatchToProps)(home))

有thunk可以进行异步请求：：：：：：：：：：：：

TodoAPIUtil
      .fetchTodos()
      .then(todos => dispatch(receiveTodos(todos)))


#教师端(公众号 vue )：https://xqmcm.com/app/teacher/index.html 

2.1-----history模式配置失败的原因可能是url带参数没有用encodeURIComponent

2.2-----(要保证你的h5页面域名和公众号后台js安全域名一致）

2.3-----微信分享到朋友圈onMenuShareTimeline成功后的回调函数不执行的问题
setTimeout(function(){undefined
          将指定的代码移出本次执行,等到下一轮Event Loop
     }, 500);
     
2.4-----支付、购买
    /**
     * 购买支付-充值-向微信发起获取openid请求，请求成功后微信会将openid返给后台   --- 1   备注： 登录后查看后台返回的openid是否有值，若没有值，则向微信发送请求  (不要走接口，直接跳链接)
     */
    applyForOpenid(params) {
        let serverUrl = urlencode(baseconfig.baseURL)
        return Get(`https://open.weixin.qq.com/connect/oauth2/authorize?appid=**yourappid**&redirect_uri=${serverUrl}/oauth/val&response_type=code&scope=snsapi_base&state=${params}#wechat_redirect`)
    },
    /**
     * 购买支付-充值-从后台获取微信返回的openid   --- 2 备注：充值时先看cookie中openid是否有值，若没有值，则从后台请求openid，请求回来也要存入cookie；然后调接口获取微信支付接口所需信息--打开支付界面进行支付
     */
    getOpenid(params) {
        // return Get(`/wechatusercenter/getOpenid?userid=${params.userid}`)
        return Get(`/oauth/openidByWeb?code=${params.code}&state=${params.userid}`)
    },
    /**
     * 购买支付-充值-从后台获取微信支付接口所需信息   --- 3
     */
    getWeChatPayInfo(params) {
        return Post('/wechatorders/recharge',params)
    },
    /**
     * 购买支付-充值-打开微信支付界面进行支付   --- 4
     */
2.5-----微信登陆


#:团长端微信小程序。
3.1-----监听订单变化 单一修改 不需要批量更新

# 11111
	 核销订单 
	async confirmOrder(params: { orderNo: string }): Promise<void> {
		const detail = await this.getOrderDetail({ orderNo: params.orderNo });
		this._events.emit('order:detail:change', detail);
	}

2222222
# /** 监听订单状态改变 */
subscribeOrderDetailChange(listener: (order: IOrderPage.OrderDetail) => void): () => void {
		//5
		this._events.on('order:detail:change', listener);

		return () => {
			this._events.off('order:detail:change', listener);
		};
	}

###### /** 回显*/  事先监听  当出发核销订单  触发回调 111111  4444
useOrderDetailChange(detail => { //4

	});

export function useOrderDetailChange(cb: (order: IOrderPage.OrderDetail) => void): void {
	const cbFn = usePersistFn(cb);

	useEffect(() => {
		const unSubscribe = orderApi.subscribeOrderDetailChange(no => {  //2222222
			cbFn(no);
		});
		return unSubscribe;
	}, [cbFn]);
}

3.2-----解锁 上锁：：：：：：：：：：：：：：：：：：：：：：：：：
只允许一个线程写入（其他线程既不能写入也不能读取）当完成是其他的线程可以继续
没有写入时，多个线程允许同时读（提高性能）

案例：：：：：接口如何防刷 
同一客户端次数限制。这个前端的一般使用是给接口调用加锁，在返回结果或者一定时间之后解锁。

3.3-----输入框的 防流 节抖：：：：：：：：：：：：：：：：：：
const debouncedValue = useDebounce(values, 200);
	useDebounceFn(
		() => {
			alert(1111);
		},
		[value],
		2000,
	);


# 转盘游戏(桥接至app 支付宝小程序 微信小程序)。 
4.1-----页面跳转
loadScript('//res.wx.qq.com/open/js/jweixin-1.6.0.js');  RwMutex  writeLock

4.2-----登录 分享:
const env = await PLATFORM_BRIDGE.getRunningEnv();
微信环境----ios的 ua 中无 miniProgram，很坑爹,但都有 MicroMessenger（表示是微信浏览器）

4.3-----安卓ios-----webview
async setNavWechatShare(shareInfo: NativeWechatShareInfo): Promise<void> {
		this.invokeBridge('setNavWechatShare', shareInfo);
	}
const iosBridge = win.webkit && win.webkit.messageHandlers && win.webkit.messageHandlers.FNJSBridge;
const androidBridge = win.FNJSBridge;

iosBridge.postMessage(msg);
androidBridge.callHandler(method, param ? JSON.stringify(param) : '', id);

# 4.4-----usePersistFn可以保证函数地址永远不会变化：：：：：：：：：：：   将函数存在useRef中
子组件回调 onLuckDraw={handleLuckDraw}

handleSubmit

父组件 setSelectKey(_index + 1) 改变 selectKey

子组件依赖key   selectKey  

当其改变的时候会触发 handleLuckDraw  这个函数回调会触发(回调展示抽中奖品)onViewPrize  改变 setSelectKey(null);

  useEffect(() => {
        if (selectKey !== null) {
            handleLuckDraw(selectKey);   //这个方法又触发父组件的回调    父组件的回调中又改变selectKey
        }
    }, [selectKey, handleLuckDraw]);

    const handleLuckDraw = usePersistFn((v: number) => { })

export function usePersistFn<T extends (...args: any[]) => any>(fn: T): T {
	const fnRef = useRef<T>(fn);
	fnRef.current = fn;

	const persistFn = useRef<T>();
	if (!persistFn.current) {
		persistFn.current = function (...args) {
			// eslint-disable-next-line @typescript-eslint/ban-ts-comment
			// @ts-ignore
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			return fnRef.current!.apply(this, args);
		} as T;
	}

	// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	return persistFn.current!;
}


# 4.5-----web-animations-js polyfill：：：：：：：：：

没有找到 window.requestAnimationFrame 

(function () {
	let lastTime = 0;
	if (!window.requestAnimationFrame)
		window.requestAnimationFrame = function (callback) {
			const currTime = new Date().getTime();
			const timeToCall = Math.max(0, 16 - (currTime - lastTime));
			const id = window.setTimeout(function () {
				callback(currTime + timeToCall);
			}, timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};

	if (!window.cancelAnimationFrame)
		window.cancelAnimationFrame = function (id) {
			clearTimeout(id);
		};
})();

#?? 贝兹尔曲线  一阶函数 二阶函数  二项式定理


4.6
rafPolyfill  raf






# 秒杀系统(taro node  express  sequelize  mysql  redis  nginx  docker  docker-compose)


# taro 小程序 


#:fnx react-hooks移动端组件 (https://rockcookies.github.io/fnx-ui/#/zh-CN/components/badge)


.umi   是可扩展的企业级前端应用框架
gulp   gulp是一个基于流的构建工具
lerna  是一个专门用于管理带有多个包的JavaScript项目的工具，可以帮助进行npm发布及git上传

1：lerna init 生成 packages
2：yarn dev----------------lerna exec -- [..args] # 在所有包中运行该命令    "dev": "lerna exec --scope fnx-ui yarn dev",
3：项目使用vite构建
4：开发一个符合公司的脚手架

6.2：问题
不能识别md文件？
为什么webpack可以引入loader的方式加载md文件？
如何编写vite插件？
vite不是基于webpack为什么不可以引入loader怎么写插件解决？


(前提创建一个项目需要用别人的脚手架 比如: vue-cli create-react-app)
# 定制公司项目脚手架 


？？？
8： 项目开发--打包---提交git---部署服务器----发布 



# webpack

手写webpack打包工具的loader
手写webpack打包工具的插件plugin
实现简易版webpack

# 文件上传 七牛云 阿里OSS



# 大厂代码规范

# ! eslint 
作用：代码质量检查  代码格式化

# ! prettier

husky




# 前端性能优化

【减少重定向】
尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，
也没有任何组件会被下载，降低了用户体验

如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。
因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面

【使用DNS预解析】
  当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址
  DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度
  方法是在 head 标签里面写上几个 link 标签
  对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间

link 代替 @import
加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。