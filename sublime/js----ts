export PUB_HOSTED_URL = https://pub.flutter-io.cn

# 编译语言的JavaScript
分词 / 词法分析------解析 / 语法分析------代码生成


# 变量提升 函数提升
var 存在变量提升 (var在全局作用域声明的变量有一种行为会挂载在window对象上)   注意：变量赋值不会被提升
const 同样可以用来创建块作用域变量, const声明的是常量, 只读, 修改值会报错 
let 声明的变量没有var那样的变量提升----暂时死区(禁止重复声明)

( `函数声明` (function a() { })会被提升，但是 `函数表达式` (var a = function () { }) 却不会被提升。) (函数优先！！！！再其次是变量)

let myObj= {
  mealA: 'Breakfast',
  mealB: 'Lunch',
  mealC: 'Dinner'
};

for (var key in myObj) {
  console.log(key, myObj[k]);
}

for (let [key, value] of Object.entries(myObj)) {
  console.log(key + ':' + value);
}


# Promise.race或者  new promise 内部设置回调

promise的信任问题：：：：：：：：：：：：：：
// 不要只是这么做：
foo(42)
  .then(function (v) {
    console.log(v);
  });
// 而要这么做：
Promise.resolve(foo(42))
  .then(function (v) {
    console.log(v);
  });


扩展：
Promise
在 pending 状态 , promise 可以切换到 fulfilled 或 rejected。
在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。
在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。


Async / Await - 定义异步函数
自动把函数转换为 Promise
当调用异步函数时，函数返回值会被 resolve 处理
异步函数内部可以使用 await


# 多个异步函数同时执行时，需要借助 Promise.all  
await 把异步变成了同步。
async function getABC() {
  let A = await getValueA();  getValueA 花费 2 秒
  let B = await getValueB();  getValueA 花费 4 秒
  let C = await getValueC();  getValueA 花费 3 秒

  return A * B * C; 总花费9秒

  return await Promise.all([getValueA, getValueB, getValueC]); 总花费4秒
}

# async await  promise
async function async1(){
 return new Promise(resolve=>{
     resolve(2);
 })
}

async function async2(){
  let c = await async1(); //2
  //加上 await 结果就是2
  let d = new Promise((resolve,reject)=>{
  resolve(c); 
})
console.log("d为多少");
console.log(d); //Promise {<fulfilled>: 2}
}
async2();


# asnyc await    try catch   promise
async function fn() {
    try {
        await new Promise(() => {
            throw new Error('new promise throw error');
        })
        // 如果加上promise的catch 那么优先抛出
        .catch(error=>{
            console.log('.catch',error);
        })
    } catch (error) {
        console.log(error);
    }
}
fn()

这次Promise异常能被捕获到,
是因为async和await,
正常不加async,await的时候,
执行promise后,在等待promise回调的时候,
try,catch已经执行完了,所以捕获不到,
然而加了async和await后,try,catch必须等promise的回调执行完后
,才能继续往下走,这个时候trycatch没执行完,promise抛出异常,自然而然能被catch捕获到


# new操作符的作用
1；创建了一个空对象
var obj=new Object();

2：设置原型链
obj.__proto__= Func.prototype;

3：(改变this指向)让Func中的this指向obj，并执行Func的函数体。
var result =Func.call(obj);


# call bind apply用法：：：：https://zhuanlan.zhihu.com/p/82340026

1：call
  (function (name) {
    //
  })("aa");
//等价于
(function (name) {
  //
}).call(window, "aa");

函数作为对象的方法被调用(那么this就是这对象)

function hellofn(thing) {
  console.log(this + " says hello " + thing);
}

let person = { name: "caibirdme" };
person.hellofn = hellofn;
person.hellofn("world");//[object Object] says hello world
//相当于person.hellofn(person,"world")

person.innerobj = {
  name: "innerobjname",
  f: function () { console.log(this.name); }
}
person.innerobj.f(); // 相当于obj.innerobj.f.call(obj.innerobj)
// ==> innerobjname


(call apply 本质是一样的但是接受参数的方式可能不一样：：：：：：：：：：：：
func.call(this, arg1, arg2)
func.apply(this, [arg1, arg2]))

# 验证是否数组：：：：：：：：：：：：：：：：：：
1：console.log(Array.isArray(a));  //true
2：functionisArray(obj){
  return Object.prototype.toString.call(obj) === '[object Array]';
}
3：console.log(a instanceof Array);
4：通过对象原型链上的isPrototypeOf()判断  Array.prototype.isPrototypeOf(a)

var args = Array.prototype.slice.call(arguments); arguments是伪数组
args.unshift('(app)');
console.log.apply(console, args);

apply 、 call 、bind 三者都是用来改变函数的this对象的指向的
apply 、 call 、bind 三者第一个参数都是this要指向的对象, 也就是想指定的上下文
apply 、 call 、bind 三者都可以利用后续参数传参
bind 是返回对应函数, 便于稍后调用, apply 、call 则是立即调用。

const obj = {
  x: 10
}
function fn() {
  console.log(this)
}
fn.call(obj)      //obj
fn.apply(obj) //obj
fn.bind(obj)() //obj

4.1: 判断类型
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(“abc”);// "[object String]"
Object.prototype.toString.call(123);// "[object Number]"
Object.prototype.toString.call(true);// "[object Boolean]"
Object.prototype.toString.call(new Date()); // "[object Date]"
Object.prototype.toString.call([1, 2, 3]); // "[object Array]"


# 执行上下文
评估和执行 JavaScript 代码的环境的抽象概念
执行栈:也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO(后进先出)数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

# 1: 闭包和递归：：：：：：：：：：：：：：：：：：：：：：：

闭包就是能够读取其他函数内部变量的函数。
function a() {
  let pa = 'a的变量'
  const b = () => {
    let pb = 'b的变量'
  }
}
const c = a.b
console.log('闭包就是能够读取其他函数内部变量的函数。', c)

function fun(a) {
  function f2() {
    console.log(a);
  }
  return f2;
}
let fn = fun(1)
console.log(fn)
setTimeout(fn, 1000)


function f1() {
  var sum = 0;
  console.log('111sum', sum)
  var obj = {
    inc: function (e) {
      console.log(sum, e, 'sum')
      sum++;
      return sum;
    }
  };
  return obj;
}
let result = f1();
console.log(result.inc());//1
console.log(result.inc());//2
console.log(result.inc());//3


闭包使用场景：：：：：：：：：：：：：：：：：
1：setTimeout 原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果
2：回调
3：函数防抖 返回一个函数 参数是函数
4：封装私有变量 创建一个计数器
5：当我们需要在模块中定义一些变量,并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来定义这个模块。

##! MVVM,理解闭包的艺术：：：：：：：：：：：：：：：：：
https://juejin.cn/post/6844903619808985095


# 递归 -：：：：：：：：：：：：：：：：：：：：
const multiply = (A, B) => {
  if (A === 1) {
    return B;
  } else {
    return B + multiply(A - 1, B);
  }
};

# 扩展：函数柯里化：：
function curry(fn, args) {
  var length = fn.length;
  args = args || [];
  return function (...rest) {
    var _args = [...args, ...rest];
    return _args.length < length
      ? curry.call(this, fn, _args)
      : fn.apply(this, _args);
  }
}
var fn = curry(function (a, b, c) {
  console.log(a + b + c);
});
fn('a', 'b', 'c'); // abc
fn('a', 'b')('c'); // abc
fn('a')('b')('c'); // abc



# forEach、map、filter、reduce、every、some的区别联系：：：：：：：：：：：
forEach：  让数组中的每一项做一件事
map： 让数组的通过某种计算产生一个新的数组
filter： 筛选出数组符合条件的项 组成一个新数组
reduce： 让数组的前项和后项做某种计算 并累计最终值   //[1,2,3,4,5].reduce((prev,next)=>return prev+next)
every： 检测数组的每一项是否符合条件 全部符合就是true
some： 检测数组中的某一项是否符合条件 一项符合即可
splice：操作函数：

# 对象操作：：：：：：：：：：：：：：：：：：：：：：：：：：：
var copy = Object.assign({}, obj)
var obj = { 0: 'a', 1: 'b', 2: 'c' } console.log(Object.keys(obj))---console: ['0', '1', '2'] console.log(Object.values(obj))----['a', 'b', 'c']
const obj = { foo: 'bar', baz: 42 }-----console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]   
var obj = { a: 'ss', b: 'bb', c: 'cc' }---------for (var i in obj) { console.log(i + '--------' + obj[i]) }
Object.defineProperty(obj, prop, descriptor)



# new WeakMap用法：：：：：：：：：：：：：：：：：：：：：：
WeakMap的作用就是可以更有效的垃圾回收、释放内存。
let myWm = new WeakMap()
// 删除键
myWm.delete(key);
// 设置键和值------------key只能是对象 myWm.set(()=>{}, 1) myWm.set(new Date(), '鑫空间');
myWm.set(key, value);
// 是否包含某键
myWm.has(key);
// 获取键对应的值
myWm.get(key);


#  事件流  捕获和冒泡
<div class="box" id="box1">
  <div class="box" id="box2">
    <div class="box" id="box3">
      <div class="box" id="box4">
        <div class="box" id="box5">
          <div class="box" id="box6">点击</div>
        </div>
      </div>
    </div>
  </div>
</div>

捕获:
Window-->Html-->Body-->Box1-->Box2-->Box3
冒泡:
Box3-->Box2-->Box1-->Body-->Html-->Window

 _temp.addEventListener("click", doCurrent, true) (当第三个参数设置为true就在捕获过程中执行,反之就在冒泡过程中执行处理函数)

(在标准的“DOM2级事件”中规定,事件流首先是经过事件捕获阶段，接着是处于目标阶段，最后是事件冒泡阶段)

#?  stopPropagation 阻止事件的冒泡和捕获。
因为事件可以在各层级的节点中传递, 不管是冒泡还是捕获, 有时我们希望事件在特定节点执行完之后不再传递, 可以使用事件对象的 stopPropagation() 方法。
#?preventDefault 阻止浏览器默认行为。
浏览器的默认行为：对于一些特定的事件，浏览器有它默认的行为。
例如：
点击链接会进行跳转
点击鼠标右键会呼出浏览器右键菜单
填写表单时按回车会自动提交到服务器等
#? return false;
当你调用它时会做 3 件事：
event.preventDefault() – 它停止浏览器的默认行为。
event.stopPropagation() – 它阻止事件传播（或“冒泡”）DOM。
停止回调执行并立即返回。







# reduce 高级用法：https://juejin.cn/post/6844903669977055239
var res = arr.reduce((x, y) => x.concat(y), []);

var result = [
  { subject: 'math', score: 88 },
  { subject: 'chinese', score: 95 },
  { subject: 'english', score: 80 }
];
var dis = {
    math: 0.5,
    chinese: 0.3,
    english: 0.2
};
var res = result.reduce((accumulator, cur) => dis[cur.subject] * cur.score + accumulator, 0);


# 事件冒泡/事件捕获，事件代理（事件委托）：：：：：：：：：：：：：：：：：：：：：：：：：：：


原型和原型链 ：：：：：：：：：：：：：：：：：：：：：：：：：：：


33个基本知识：：：：：：：：：：

值类型(基本类型)：字符串(string)、数值(number)、布尔值(boolean)、undefined、null 
(这5种基本数据类型是按值访问的,因为可以操作保存在变量中的实际的值)
ECMAScript 2016新增了一种基本数据类型 symbol http://es6.ruanyifeng.com/#docs/symbol 
• 符号(symbol)ES6 中新增------- 一个 symbol 实例可以被赋值到一个左值变量，还可以通过标识符检查类型 （可以非常有效的消除magic string和magic number）
var identity = Symbol()
var obj = {
  name: 'john',
  [identity]: 'hero'
}
obj.name   //'john'
obj[name]  //'john'
obj.identity   //undefined
obj[identity]  //'hero'
//当我们使用.来访问时，因为不存在这个key，所以就会返回undefined，也符合上方所写的

#?? 引用类型：对象（Object）、数组（Array）、函数（Function）
都具有对象特性，即可自由扩展属性
都有一个隐式原型 __proto__ 属性，属性值是一个普通的对象。

const obj = { a: 1 }
obj.toString
当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 __proto__（也就是它的构造函数的显式原型 prototype）中寻找
obj 对象并没有 toString 属性，之所以能获取到 toString 属性，是遵循了第四条规则，从它的构造函数 Object 的 prototype 里去获取。

判断数据类型：：：：：：Object.prototype.toString.call(type).slice(8, -1);

#! 显式类型与隐式类型:::::
'1' * 'a' //NaN
console.log([] == []) // false
console.log([] == ![]) // true
console.log([] !== [])  // true
console.log(NaN != NaN) // true
console.log(null == undefined) // true
console.log(null === undefined) // false

显式类型转换:Number()、parseInt()、parseFloat()
隐式类型转换:当使用`+`运算符连接一个字符串和一个数字时，JavaScript会自动将数字转换为字符串并进行字符串拼接


####! 值传递 + 栈 + 堆 + 内存 :::::::::::
在JS的变量传递中,本质上都可以看成是值传递,只是这个值可能是基础数据类型，也可能是一个引用地址，
如果是引用地址,我们通常就说为引用传递。JS中比较特殊,
不能直接操作对象的内存空间，必须通过指针（所谓的引用）来访问。

堆是一种经过排序的树形数据结构，每个结点都有一个值。
通常我们所说的堆的数据结构，是指二叉堆。
堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。
由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，
虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，
我们只需要关心书的名字。

#? 栈 堆 优缺点
栈内存由于它的特点，所以它的系统效率较高。 堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。

#? 栈 堆 回收
栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，
因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。

🌰：
// 基本数据类型-栈内存
let a1 = 0;
// 基本数据类型-栈内存
let a2 = 'this is string';
// 基本数据类型-栈内存
let a3 = null;

// 对象的指针存放在栈内存中，指针指向的对象存放在堆内存中
let b = { m: 20 };
// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中
let c = [1, 2, 3];

🌰: 
let m = { a: 10, b: 20 };
let n = m;
n.a = 15;
console.log(m.a) //此时m.a的值是多少，是10？还是15？   答案是 15


; 堆 和 栈
let obj1 = { name: 'a' }
let obj2 = obj1
obj2.name = 'b'
console.log(obj1.name) // b
以上代码中，obj1 和 obj2 指向了同一个堆内存，obj1 赋值给 obj2，
实际上这个堆内存对象在栈内存的引用地址复制了一份给了 obj2，所以 obj1 和 obj2 指针都指向堆内存中的同一个。




# typeOf用法和instanceof用法：：：：：：：：：：：：：：：：：

作用：typeof可以判断数据类型,但是无法判断array和object

Undefined	“undefined”
Null	“object”
布尔值	“boolean”
数值	“number”
字符串	“string”
Symbol(ECMAScript 6 新增)	“symbol”
宿主对象(JS环境提供的，比如浏览器)	Implementation - dependent
函数对象	“function”
任何其他对象	“object”



# instanceof用法：
instanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。
作用：instanceof主要的目的是检测引用类型, 判断对象是Array, 还是RegExp!

eg：
function Foo(name) {
  this.name = name;
}
var f = new Foo('nick')

f instanceof Foo // true
f instanceof Object // true

f 的隐式原型 __proto__ 和 Foo.prototype


判断数组：：：
Array.isArray(target)







eventBus：：：：：：：：：：：：：：：：：：：：：：：

# JS 设计模式23种
代理模式：
let Flower = function() {}
let xiaoming = {
  sendFlower: function(target) {
    let flower = new Flower()
    target.receiveFlower(flower)
  }
}
let B = {
  receiveFlower: function(flower) {
    A.listenGoodMood(function() {
      A.receiveFlower(flower)
    })
  }
}
let A = {
  receiveFlower: function(flower) {
    console.log('收到花'+ flower)
  },
  listenGoodMood: function(fn) {
    setTimeout(function() {
      fn()
    }, 1000)
  }
}
xiaoming.sendFlower(B)
状态模式
观察者模式


JS的20个实用技巧：：：：：：：：：：：：：：：：：   https://juejin.cn/post/7083016475547533348


const {a,b,c,d,e} = obj || {};


const a = [1,2,3];
const b = [1,5,6];
const c = [...new Set([...a,...b])];//[1,2,3,5,6]

const obj1 = {
  a:1,
}
const obj2 = {
  b:1,
}
const obj = {...obj1,...obj2};

如果是精确搜索不会用ES6中的find吗？性能优化懂么，find方法中找到符合条件的项，就不会继续遍历数组。
const a = [1,2,3,4,5];
const result = a.find( 
  item =>{
    return item === 3
  }




使用reduce实现数组filter方法
const myFilter2 = function (fn, context) {
  return this.reduce((total, current, index) => {
    return fn.call(context, current, index, this) ? [...total, current] : [...total]
  }, [])
}



#!!!  前端遍历合集
https://owen027.github.io/2019/07/03/performance/

# 1：for
for (int i = 0; i < 10; i++) {

	continue // 后面的语句不执行，进入下一次 //  continue一般配合判断条件使用

  break // 跳出当前循环	 // 一般配合判断语句使用

  return 当程序运行到 return; 语句时，会终止循环，结束当前方法。
}

# 2： for( ...in )
for (let key in {a:1, b:2, c:3}) {
  console.log(key); /a b c
}

# 3： for( ...of )
for (let value of [1,2,3]) {
  console.log(value); /1 2 3
}

配合使用 Object.keys({a:1,b:2}) //[a,b]
for(var key of Object.keys({a:1, b:2, c:3})){
    console.log(key); 
}

#4： while 
var n = 0;
var x = 0;
while (n < 3) {
  n++;
  x += n;
}
console.log(n,x);//3 6

# 4.1：do-while
var i = 0;
do {
   i += 1;
   result += i + ' ';
} while (i < 5); 1 2 3 4 5

# 5： switch case 
const expr = 'Mangoes';
switch (expr) {
  case 'Oranges':
    console.log('Oranges are $0.59 a pound.');
    break;
  case 'Mangoes':
  case 'Papayas1':
    console.log('Mangoes and papayas are $2.79 a pound.');
    // expected output: "Mangoes and papayas are $2.79 a pound."
    break;
  default:
    console.log(`Sorry, we are out of ${expr}.`);
}

# 6：forEach()
遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次 .无法break中途跳出循环 不可控
forEach删除自身元素index不会被重置
arr.forEach((item, index) => {
    arr.splice(index, 1);
}); 当index=0,时 进入删除,然后进入下一次遍历index=1,而此时index=1 的项是第三项

创建新数组 不改变原数组  输出的是 return什么就输出什么 新数组
map 生成的新数组元素是可自定义。与filter相反
回调函数参数,item(数组元素)、index(序列)、arr(数组本身)

# 8：find()
和filter相似 输出的是一旦判断为true 则跳出循环输出符合条件的数组元素

# 9：some()
判断出一个符合条件则跳出循环并输出true

# 10：every()
判断出一个符合条件则跳出循环并输出true

# 11：filter
创建新数组 不改变原数组 输出的是 判断为true的数组元素 组成的新数组
filter 生成的新数组元素不可自定义，与对应原数组元素一致。
回调函数参数，item(数组元素)、index(序列)、arr(数组本身)
arr.filter(function(item,index){ return item>2&&item<5 })

# 12：findIndex 和 find一样 只是返回的是索引

# 13：reduce
创建新数组 不改变原数组 输出的是return叠加什么就输出什么 新数组
pre(第一次为数组第一项，之后为上一操作的结果)
next(数组的下一项)
index(next项的序列)
arr(数组本身)
回调函数后的改变第一项参数。（不影响原数组）


## forEach 解决方案
[...arr].forEach((item, index) => {
    arr.splice(index, 1);
    console.log(1);
});


# 循环遍历函数集合： https://www.xiabingbao.com/post/loop/js-loop-speed.html

for循环 for (let k = 0; k < 10; k++) {}    能够随时 break 停止

for (let k = 0; k < 10; k++) { if(k>5){ 
 break;} console.log(k) }

while (i < len) {
    sum += arr[i] % 100;
    i++;
  }

   do {
    sum += arr[i] % 100;
    i++;
  } while (i < len);

forEach, map, reduce这几种方法是无法停止循环的,无论使用break还是return
forEach, map, reduce 3 个循环的时间差不多

forEach
[1, 2, 3, 4, 5].forEach((item) => {}


for...of 的简要介绍  for-of 循环速度前两次很低
一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。也就是说，for...of 循环内部调用的是数据结构的 Symbol.iterator 方法。

for...of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。

for...of 拿到的就是 value 本身，而 for-in 则拿到的是 key,然后通过 key 再获取到当前数据。

for...of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。

for (const value of arr) {
    sum += value % 100;
  }


for-in 循环  循环效率真的很低!!!!!!
for-in 通常用于 object 类型的循环，但也可以用来循环数组，毕竟所有数据类型的祖先都是 object 类型。

for (let key in arr) {
    sum += arr[key] % 100;
  }




# 懒加载也叫延迟加载

# 预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。
组件: createjs 中的 preloadjs
let mainfest = ['img1','img2']
 startPreload() {
    var preload = new createjs.LoadQueue(true);
    //为preloaded添加整个队列变化时展示的进度事件
    preload.addEventListener('progress', this.handleFileProgress);
    //为preloaded添加当队列完成全部加载后触发事件
    preload.addEventListener('complete', this.loadComplete);
    //设置最大并发连接数  最大值为10
    preload.setMaxConnections(1);
    preload.loadManifest(this.mainfest);
  }
  // 当整个队列变化时展示的进度事件的处理函数
  handleFileProgress(event) {
    this.setState({
      num: Math.ceil(event.loaded * 100) + '%',
    });
  }
  loadComplete() {
    this.props.history.push({
      pathname: '/index',
    });
  }

# 按需加载
使用babel/plugin-syntax-dynamic-import插件

# 使用 "use strict" 指令
"use strict" 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。
它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。
"use strict" 的目的是指定代码在严格条件下执行。
严格模式下你不能使用未声明的变量。



##TYPESCRIPT（ts）
ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：

# 接口iterface 和 类型别名type 的关联和区别：：：：：：：：：
1：都可以描述 对象和函数
interface SetSister {
  name: string;
  (name: string, age: number): void;
}
2： 都可以扩展 但是 type是 & 。interface是extends
3： interface扩展是不可以重复
4: type可以并用两个接口, 而接口不可以并用接口
interface Admin {
  name: string;
  privileges: string[];
}
interface Employee {
  name: string;
  startDate: Date;
}
type UnknownEmployee = Employee | Admin;

# implements与extends的区别：：：：：：：：：：：：：：：：

extends继承，一个新的接口或者类，从父类或者接口继承所有的属性和方法，不可以重写属性，但可以重写方法
implements是对某个接口或者类型的实现继承，必须满足接口的类型规范。


泛型（Generics）是允许同一个函数接受不同类型参数的一种模板：：：：：：：：：：
T （Type）
K（Key）：表示对象中的键类型；
V（Value）：表示对象中的值类型；
E（Element）：表示元素类型。

1：function aname<T>(value: T): T {
  return value;
}
2：function identity<T, U>(value: T, message: U): T {
  console.log(message);
  return value;
}
3：const bname = <T>(x: T): T => {
	return x;
};
/**  Record<string, unknown> 相当于{ } */
  4：const cname = <T extends Record<string, unknown>>(x: T): T => x;
  5：const dname =
  <T1 extends Record<string, unknown>>(arg1: T1) =>
  <T2 extends Record<string, unknown>>(arg2: T2) => {
		return {arg1, arg2};
	};

  字符串枚举+常量枚举=异构枚举
  类型断言： <string>someValue =====  someValue as any
    Partial<T> 的作用就是将某个类型或者接口里的属性全部变为可选项 ?

      JSON数据格式转ts接口： http://ww7.jsontots.com/

      高级类型技巧： https://juejin.cn/post/6994102811218673700#heading-6



      class Greeter {
        // 静态属性
        static cname: string = "Greeter";
      // 成员属性
      greeting: string;

      // 构造函数 - 执行初始化操作
      constructor(message: string) {
        this.greeting = message;
  }

      // 静态方法
      static getClassName() {
    return "Class name is Greeter";
  }

      // 成员方法
      greet() {
    return "Hello, " + this.greeting;
  }
}

      let greeter = new Greeter("world");


      编译成ES5代码：：：：：：：：：：：：：：：：：：：

      "use strict";
      var Greeter = /** @class */ (function () {
        // 构造函数 - 执行初始化操作
        function Greeter(message) {
          this.greeting = message;
        }
    // 静态方法
    Greeter.getClassName = function () {
      return "Class name is Greeter";
    };
      // 成员方法
      Greeter.prototype.greet = function () {
      return "Hello, " + this.greeting;
    };
      // 静态属性
      Greeter.cname = "Greeter";
      return Greeter;
}());
      var greeter = new Greeter("world");



# 前端装饰器

###!  js byte bit  二进制 八进制 十进制 十六进制

1byte(字节) = 8bit(位) 怎么理解？？
1字节(byte)等于8位(bit),这是因为计算机中的数据存储和传输是以位为单位的。
位是计算机中最小的存储单位,它可以表示0或1两种状态。而字节是由8个位组成的,可以表示256种不同的状态(2的8次方)
🌰：一个字节可以表示的最小值是00000000(二进制)相当于(十进制的0),最大值是11111111(二进制),相当于十进制的(255)

Number类型在内存中占用的空间通常是8个字节(64位) 通常被放在栈内存中
JavaScript使用了Unicode字符集来表示字符串,其中大多数字符使用16位编码(即2个字节)。然而，对于一些特殊字符（如表情符号、某些汉字等），可能需要使用更多的字节来表示。

1byte = 8bit
1byte = 1B
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB

a=25
b=0b11001;// 0b表示二进制  
c=0o31;// 0o 八进制 
d=0x19;//0x 十六进制

##? 十进制  用10个符号来表示一个数字 0123456789
🌰  235 === 2*10^2 + 3*10^1 + 5*10^0 (个位 十位 百位) === 200+30+5

🌰  29<10> === 
    29/2 ==14余：1
    14/2 ==7 余：0
    7/2  ==3 余：1
    3/2  ==1 余：1 
    1/2  ==0 余：1
    ===11101<2>  反向排列

##? 二进制  用两个符号来表示一个数字 01
🌰  1011<2> === 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 === 8+0+2+1 === 11<10>

🌰  110<2> === 1*2^2 + 1*2^1 + 0*2^0 + 1*2^0 === 4+2+0 === 6<10>

    #!由于2^3为8 所以每三位二进制可以转换为一位八进制
🌰  10111001<2>===
    10  ==1*2^1+0*2^0 =2
    111 ==1*2^2 + 1*2^1 + 1*2^0==7
    001 ==0*2^2 + 0*2^1 + 1*2^0==1
    === 271<8>
    

##? 八进制  用八个符号来表示一个数字 01234567
🌰  377<8> ==== 3*8^2 + 7*8^1 + 7*8^0 === 192+56+7 ===255<10>

🌰  900<10> === 
    900/8 ==112余：4
    112/8 ==14 余：0
    14/8  ==1  余：6
    1/8   ==0  余：1 
    ===1604<8>(反向排列)

##? 十六进制  用十六个符号来表示一个数字 
0123456789 A  B  C  D  E  F
0123456789 10 11 12 13 14 15

🌰  177<16> ==== 1*16^2 + 7*16^1 + 7*16^0 === 256+112+7 ===375<10>

🌰  2717<10> === 
    2717/16 ==169 余：13
    169/16  ==10  余：9
    10/16   ==0   余：10
    ===A9D<10>(反向排列)

    #!由于2^4为16 所以每四位二进制可以转换为一位十六进制
🌰  10111001<2>===
    1011  ==1*2^3 + 0*2^2 + 1*2^1 +1*2^0 == 8+0+2+1 == 11 == B
    1001 ==1*2^3 + 0*2^2 + 0*2^1 + 1*2^0 == 8+1 == 9
    ===B9<16>


#?小问答：八进制的1111 可以转换为二进制的多少？


###!  cryptojs  md5  sha1 sha256  ase 加密方式


#!   web worker基本用法
demo:https://codesandbox.io/s/new-breeze-6r3578?file=/src/worker.js

## main.ts

import React from 'react';
import worker_script from './web-worker.ts';

class MyClass extends React.Component {
  constructor() {
    super();

    this.state = { clickCount: 1 };
    this.handleClick = this.handleClick.bind(this);
  }

  componentDidMount() {
    this.worker = new Worker(worker_script);
    this.worker.onmessage = (ev) => {
      console.log('结果返回：got data back from worker');
      console.log(ev);
    };
  }

  handleClick() {
    console.log('Posting message');
    this.worker.postMessage('Button clicked');
  }

  render() {
    return (
      <div>
        myClass test
        <button onClick={this.handleClick}>Click to trigger worker</button>
      </div>
    );
  }
}

export default MyClass;

##  worker.ts

const workercode = () => {
  self.onmessage = function (e) {
    // self.importScripts("./testModule"); // eslint-disable-line no-restricted-globals
    // eslint-disable-line no-restricted-globals
    console.log('Message received from main script');
    setTimeout(() => {
      var workerResult = 'Received from main: ' + e.data;
      console.log('Posting message back to main script');
      // self.postMessage(api.message()); // eslint-disable-line no-restricted-globals
      self.postMessage(workerResult); // eslint-disable-line no-restricted-globals
    }, 3000);
  };
};

let code = workercode.toString();
code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));

const blob = new Blob([code], { type: 'application/javascript' });
const worker_script = URL.createObjectURL(blob);

module.exports = worker_script;

##!    web worker监听错误信息
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker

myWorker.addEventListener('error', err => {
    console.log(err.message);
});
myWorker.addEventListener('messageerror', err => {
    console.log(err.message)
});

// worker.js（worker线程）
self.addEventListener('error', err => {
    console.log(err.message);
});
self.addEventListener('messageerror', err => {
    console.log(err.message);
});

##!    web worker监听错误信息

// worker.js（worker线程）
self.close(); // 直接执行close方法就ok了

// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker
myWorker.terminate(); // 关闭worker

// worker.js（worker线程） 调用utils函数文件
// 使用方法：importScripts(path1, path2, ...); 
importScripts('./utils.js');