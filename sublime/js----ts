export PUB_HOSTED_URL=https://pub.flutter-io.cn

分词/词法分析------解析/语法分析------代码生成

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词
法作用域。ES6 还引入了 const,同样可以用来创建块作用域变量,但其值是固定的
（常量）。之后任何试图修改值的操作都会引起错误。

这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”
到了最上面。这个过程就叫作提升。
(只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。)
(函数声明会被提升，但是函数表达式却不会被提升。)   函数优先！！！！   再其次是变量


for (var k in myObject) {
console.log( k, myObject[k] );
}


var myArray = [ 1, 2, 3 ];
for (var v of myArray) {
console.log( v );
}

var myObject = Object.create( anotherObject );

 Object.defineProperty(..)（参见第 3 章）来向 myObject 添加 foo。
anotherObject.hasOwnProperty( "a" ); 
. class 字面语法不能声明属性（只能声明方法）
可以通过 super(..) 来实现相对多态


• 空值（null）
• 未定义（undefined）
• 布尔值（ boolean）
• 数字（number）
• 字符串（string）
• 对象（object）
• 符号（symbol，ES6 中新增）------- 一个 symbol 实例可以被赋值到一个左值变量，还可以通过标识符检查类型 （可以非常有效的消除magic string和magic number）

eg例子：：：：：：：：：：：：：
var identity = Symbol()
var obj = {
    name : 'john',
    [identity] : 'hero'
}
obj.name   //'john'
obj[name]  //'john'
obj.identity   //undefined
obj[identity]  //'hero'
//当我们使用.来访问时，因为不存在这个key，所以就会返回undefined，也符合上方所写的



Alex Dorey（GitHub 用户名 @dorey）在 GitHub 上制作了一张图表


function add(xPromise,yPromise) {
 // Promise.all([ .. ])接受一个promise数组并返回一个新的promise，
 // 这个新promise等待数组中的所有promise完成
 return Promise.all( [xPromise, yPromise] )
 // 这个promise决议之后，我们取得收到的X和Y值并加在一起
 .then( function(values){
 // values是来自于之前决议的promisei的消息数组
 return values[0] + values[1];
 } );
}
// fetchX()和fetchY()返回相应值的promise，可能已经就绪，
// 也可能以后就绪
add( fetchX(), fetchY() )
// 我们得到一个这两个数组的和的promise
// 现在链式调用 then(..)来等待返回promise的决议
.then( function(sum){
 console.log( sum ); // 这更简单！
} ); 


if (
 p !== null &&
 (
 typeof p === "object" ||
 typeof p === "function"
 ) &&
 typeof p.then === "function"
) {
 // 假定这是一个thenable!
}
else {
 // 不是thenable
}



eg例子：：：：：：：：：：：：：
1  7 6 8 2 4 3 5 9  10 11 12

eg:  6之后执行8  是因为 6是第一个微服务 执行完微服务要执行所有的微服务

eg: 2，4 ，3，5     ,,24之后要执行完这里的微服务再执行下面的微服务。下面的setimeOut是第三轮的事件循环宏服务


console.log('1');
setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

process.nextTick(function() {
    console.log('6');
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})


Promise.race或者  new promise 内部设置回调

promise的信任问题：：：：：：：：：：：：：：
// 不要只是这么做：
foo( 42 )
.then( function(v){
 console.log( v );
} );
// 而要这么做：
Promise.resolve( foo( 42 ) )
.then( function(v){
 console.log( v );
} ); 


Promise.all() 允许同时执行所有的异步函数：：：：：：：：：

扩展：
Promise
在 pending 状态，promise 可以切换到 fulfilled 或 rejected。
在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。
在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。


Async/Await - 定义异步函数
自动把函数转换为 Promise
当调用异步函数时，函数返回值会被 resolve 处理
异步函数内部可以使用 await

EG：：：：：：
多个异步函数同时执行时，需要借助 Promise.all
await 把异步变成了同步。
async function getABC() {
  let A = await getValueA(); // getValueA 花费 2 秒
  let B = await getValueB(); // getValueA 花费 4 秒
  let C = await getValueC(); // getValueA 花费 3 秒

  return A*B*C;  //总花费9秒

  return await Promise.all([ getValueA, getValueB, getValueC ]); 总花费4秒
}






call bind apply：：：：：：：：：：： https://zhuanlan.zhihu.com/p/82340026

call：：：：：：：：：：：
(function(name) {
        //
    })("aa");
    //等价于
    (function(name) {
        //
    }).call(window, "aa");

函数作为对象的方法被调用（那么this就是这对象）：：：：：：：：：：：：：：：：

function hellofn(thing) {
  console.log(this + " says hello " + thing);
}

let person = { name: "caibirdme" };
person.hellofn = hellofn;
person.hellofn("world");//[object Object] says hello world
//相当于person.hellofn(person,"world")

person.innerobj = {
    name: "innerobjname",
    f: function(){ console.log(this.name); }
}
person.innerobj.f(); // 相当于obj.innerobj.f.call(obj.innerobj)
// ==> innerobjname


(call apply 本质是一样的但是接受参数的方式可能不一样：：：：：：：：：：：：
func.call(this, arg1, arg2)
func.apply(this, [arg1, arg2]))

验证是否是数组：functionisArray(obj){ 
    return Object.prototype.toString.call(obj) === '[object Array]' ;
}

var args = Array.prototype.slice.call(arguments); arguments是伪数组
  args.unshift('(app)');
   console.log.apply(console, args);

apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；
apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；
apply 、 call 、bind 三者都可以利用后续参数传参；
bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。

//  const obj = {
//     x: 10
//   }
//   function fn() {
//     console.log(this)
//   }
//   fn.call(obj)      //obj
//   fn.apply(obj) //obj
//   fn.bind(obj)() //obj

// 4.1: 判断类型
// Object.prototype.toString.call(null); // "[object Null]"
// Object.prototype.toString.call(undefined); // "[object Undefined]"
// Object.prototype.toString.call(“abc”);// "[object String]"
// Object.prototype.toString.call(123);// "[object Number]"
// Object.prototype.toString.call(true);// "[object Boolean]"
// Object.prototype.toString.call(new Date()); // "[object Date]"
// Object.prototype.toString.call([1,2,3]); // "[object Array]"


// 1: 闭包和递归：：：：：：：：：：：：：：：：：：：：：：：

// 闭包就是能够读取其他函数内部变量的函数。
// function a() {
//   let pa = 'a的变量'
//   const b = () => {
//     let pb = 'b的变量'
//   }
// }


// const c = a.b
// console.log('闭包就是能够读取其他函数内部变量的函数。', c)

// function fun(a) {

//   function f2() {
//     console.log(a);
//   }
//   return f2;
// }

// let fn = fun(1)
// console.log(fn)
// setTimeout(fn, 1000)


// function f1() {
//   var sum = 0;
//   console.log('111sum', sum)
//   var obj = {
//     inc: function (e) {
//       console.log(sum, e, 'sum')
//       sum++;
//       return sum;
//     }
//   };
//   return obj;
// }
// let result = f1();
// console.log(result.inc());//1
// console.log(result.inc());//2
// console.log(result.inc());//3

闭包使用场景：：：：：：：：：：：：：：：：：
1：setTimeout 原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果
2：回调
3：函数防抖 返回一个函数 参数是函数
4：封装私有变量 创建一个计数器

// 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来定义这个模块。

// 减少全局变量； 减少传递函数的参数量；



递归：：：：：：：：：：：：：：：：：：：：
const multiply = (A, B) => {
   if (A === 1) {
      return B;
    } else {
      return B + multiply(A - 1, B);
    }
  };



forEach、map、filter、reduce、every、some的区别联系：：：：：：：：：：：

forEach：  让数组中的每一项做一件事
map： 让数组的通过某种计算产生一个新的数组  
filter： 筛选出数组符合条件的项 组成一个新数组
reduce： 让数组的前项和后项做某种计算 并累计最终值   //[1,2,3,4,5].reduce((prev,next)=>return prev+next)
every： 检测数组的每一项是否符合条件 全部符合就是true
some： 检测数组中的某一项是否符合条件 一项符合即可

//简洁---复用
// 5: HOC高阶组件
// const HOC = (Com) => {
//     return class tar extends Component<IProps, IState> {
//         constructor(props: IProps) {
//             super(props);
//         }
//         render() {
//             return <div>
//                 <Com  {...this.props}  > </Com>
//             </div>
//         }
//     }
// }

//调用:
// HOC(组件名)



// constructor ------   useState
// getDerivedStateFromProps --------    useState 里面 update 函数
// shouldComponentUpdate ------ useMemo
// render ------    函数本身
// componentDidMount ------ useEffect
// componentDidUpdate ------    useEffect
// componentWillUnmount ------  useEffect 里面返回的函数
// componentDidCatch ------ 无
// getDerivedStateFromError ------  无





// 6:React SSR + express 构建简单服务端渲染Demo      https://juejin.cn/post/6844903990497378318




// uploader上传文件  测试用例

// 受控组件

// eventBus

// Inter section Observer  visibilitychange

// naticeBar-----回流与重绘
// if (playing % 2 === 0) {
//   setTransitionDuration(0);
//   setOffset(wrapperWidth);
//   doubleRaf(() => setPlaying(nextPlaying));
//   return;
// }
// double raf for animation
// export function doubleRaf(fn: FrameRequestCallback): void {
//   raf(() => raf(fn));
//   requestAnimationFrame
// }

// 优化
// useState
// useReducer

// seState 就是用 useReducer 实现的，useState 返回的函数内部封装了一个 dispatch。
// 那就是 useState 不对状态做浅层合并了，而 useReducer 会合并


// 手机输入框



reduce 高级用法：https://juejin.cn/post/6844903669977055239




扩展：函数柯里化：：
function curry(fn, args) {
  var length = fn.length;
  args = args || [];
  return function(...rest) {
    var _args = [...args, ...rest];
    return _args.length < length
      ? curry.call(this, fn, _args)
    : fn.apply(this, _args);
  }
}
var fn = curry(function(a, b, c) {
  console.log(a + b + c);
});
fn('a', 'b', 'c'); // abc
fn('a', 'b')('c'); // abc
fn('a')('b')('c'); // abc








33个基本知识：

调用堆栈：


执行上下文是评估和执行 JavaScript 代码的环境的抽象概念

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。


（1）值类型（基本类型）：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol http://es6.ruanyifeng.com/#docs/symbol )

（2）引用类型：对象（Object）、数组（Array）、函数（Function）

显式类型转换与隐式类型转换：：：：：：：：：：：：：：

'1' * 'a' //NaN
console.log([] == []) // false
console.log([] == ![]) // true
console.log([] !== [])  // true
console.log(NaN != NaN) // true
console.log(null == undefined) // true
console.log(null === undefined) // false

显式类型：Number()、parseInt()、parseFloat()


typeOf用法：：：：：：：：：：：：：：：：：

Undefined	“undefined”
Null	“object”
布尔值	“boolean”
数值	“number”
字符串	“string”
Symbol (ECMAScript 6 新增)	“symbol”
宿主对象(JS环境提供的，比如浏览器)	Implementation-dependent
函数对象	“function”
任何其他对象	“object”

instanceof用法：instanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。




eventBus：：：：：：：：：：：：：：：：：：：：：：：


export function eventBus() {
	const all: Dictionary<Array<Function>> = Object.create(null);

	return {
		/**
		 * Register an event handler for the given type.
		 *
		 * @param type	Type of event to listen for, or `"*"` for all events
		 * @param handler Function to call in response to given event
		 */
		on(type: string, handler: (event?: any) => void) {
			(all[type] || (all[type] = [])).push(handler);
		},

		/**
		 * Remove an event handler for the given type.
		 *
		 * @param type	Type of event to unregister `handler` from, or `"*"`
		 * @param handler Handler function to remove
		 */
		off(type: string, handler: (event?: any) => void) {
			if (all[type]) {
				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
			}
		},

		/**
		 * Invoke all handlers for the given type.
		 * If present, `"*"` handlers are invoked after type-matched handlers.
		 *
		 * Note: Manually firing "*" handlers is not supported.
		 *
		 * @param type  The event type to invoke
		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
		 */
		emit(type: string, evt: any) {
			(all[type] || []).slice().map(handler => {
				handler(evt);
			});
			(all['*'] || []).slice().map(handler => {
				handler(type, evt);
			});
		},
	};
}


// 刷剑指offer（https://www.nowcoder.com/ta/coding-interviews）

// 算法基础知识-http://www.360doc.com/content/21/0518/19/37113458_977788938.shtml









ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：

接口iterface 和 类型别名type 的关联和区别：：：
1：都可以描述 对象和函数
interface SetSister {
  name: string;
  (name: string, age: number): void;
}
2： 都可以扩展 但是 type是& interface是extends
3： interface扩展是不可以重复