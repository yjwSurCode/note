export PUB_HOSTED_URL = https://pub.flutter-io.cn

# 编译语言的JavaScript
分词 / 词法分析------解析 / 语法分析------代码生成


# 变量提升 函数提升
var 存在变量提升 (var在全局作用域声明的变量有一种行为会挂载在window对象上)   注意：变量赋值不会被提升
const 同样可以用来创建块作用域变量, const声明的是常量, 只读, 修改值会报错 
let 声明的变量没有var那样的变量提升----暂时死区(禁止重复声明)

( `函数声明` (function a() { })会被提升，但是 `函数表达式` (var a = function () { }) 却不会被提升。) (函数优先！！！！再其次是变量)

let myObj= {
  mealA: 'Breakfast',
  mealB: 'Lunch',
  mealC: 'Dinner'
};

for (var key in myObj) {
  console.log(key, myObj[k]);
}

for (let [key, value] of Object.entries(myObj)) {
  console.log(key + ':' + value);
}



# 宏任务，微任务例子
eg: 1,3,2,4,5 之后要执行完这里的微服务再执行下面的微服务。下面的setimeOut是第三轮的事件循环宏服务

console.log('1');
setTimeout(function () {
  console.log('2');
  new Promise(function (resolve) {
    console.log('4');
    resolve();
  }).then(function () {
    console.log('5')
  })
})
console.log('3')




# Promise.race或者  new promise 内部设置回调

promise的信任问题：：：：：：：：：：：：：：
// 不要只是这么做：
foo(42)
  .then(function (v) {
    console.log(v);
  });
// 而要这么做：
Promise.resolve(foo(42))
  .then(function (v) {
    console.log(v);
  });


扩展：
Promise
在 pending 状态 , promise 可以切换到 fulfilled 或 rejected。
在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。
在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。


Async / Await - 定义异步函数
自动把函数转换为 Promise
当调用异步函数时，函数返回值会被 resolve 处理
异步函数内部可以使用 await


# 多个异步函数同时执行时，需要借助 Promise.all  
await 把异步变成了同步。
async function getABC() {
  let A = await getValueA();  getValueA 花费 2 秒
  let B = await getValueB();  getValueA 花费 4 秒
  let C = await getValueC();  getValueA 花费 3 秒

  return A * B * C; 总花费9秒

  return await Promise.all([getValueA, getValueB, getValueC]); 总花费4秒
}

# async await  promise
async function async1(){
 return new Promise(resolve=>{
     resolve(2);
 })
}
   
async function async2(){
  let c = await async1(); //2
  //加上 await 结果就是2
  let d = new Promise((resolve,reject)=>{
  resolve(c); 
})
console.log("d为多少");
console.log(d); //Promise {<fulfilled>: 2}
}
async2();


# asnyc await    try catch   promise
async function fn() {
    try {
        await new Promise(() => {
            throw new Error('new promise throw error');
        })
        // 如果加上promise的catch 那么优先抛出
        .catch(error=>{
            console.log('.catch',error);
        })
    } catch (error) {
        console.log(error);
    }
}
fn()

这次Promise异常能被捕获到,
是因为async和await,
正常不加async,await的时候,
执行promise后,在等待promise回调的时候,
try,catch已经执行完了,所以捕获不到,
然而加了async和await后,try,catch必须等promise的回调执行完后
,才能继续往下走,这个时候trycatch没执行完,promise抛出异常,自然而然能被catch捕获到


# new操作符的作用
1；创建了一个空对象
var obj=new Object();

2：设置原型链
obj.__proto__= Func.prototype;

3：(改变this指向)让Func中的this指向obj，并执行Func的函数体。
var result =Func.call(obj);


# call bind apply用法：：：：https://zhuanlan.zhihu.com/p/82340026

1：call
  (function (name) {
    //
  })("aa");
//等价于
(function (name) {
  //
}).call(window, "aa");

函数作为对象的方法被调用(那么this就是这对象)

function hellofn(thing) {
  console.log(this + " says hello " + thing);
}

let person = { name: "caibirdme" };
person.hellofn = hellofn;
person.hellofn("world");//[object Object] says hello world
//相当于person.hellofn(person,"world")

person.innerobj = {
  name: "innerobjname",
  f: function () { console.log(this.name); }
}
person.innerobj.f(); // 相当于obj.innerobj.f.call(obj.innerobj)
// ==> innerobjname


(call apply 本质是一样的但是接受参数的方式可能不一样：：：：：：：：：：：：
func.call(this, arg1, arg2)
func.apply(this, [arg1, arg2]))

# 验证是否数组：：：：：：：：：：：：：：：：：：
1：console.log(Array.isArray(a));  //true
2：functionisArray(obj){
  return Object.prototype.toString.call(obj) === '[object Array]';
}
3：console.log(a instanceof Array);
4：通过对象原型链上的isPrototypeOf()判断  Array.prototype.isPrototypeOf(a)

var args = Array.prototype.slice.call(arguments); arguments是伪数组
args.unshift('(app)');
console.log.apply(console, args);

apply 、 call 、bind 三者都是用来改变函数的this对象的指向的
apply 、 call 、bind 三者第一个参数都是this要指向的对象, 也就是想指定的上下文
apply 、 call 、bind 三者都可以利用后续参数传参
bind 是返回对应函数, 便于稍后调用, apply 、call 则是立即调用 。

const obj = {
  x: 10
}
function fn() {
  console.log(this)
}
fn.call(obj)      //obj
fn.apply(obj) //obj
fn.bind(obj)() //obj

4.1: 判断类型
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(“abc”);// "[object String]"
Object.prototype.toString.call(123);// "[object Number]"
Object.prototype.toString.call(true);// "[object Boolean]"
Object.prototype.toString.call(new Date()); // "[object Date]"
Object.prototype.toString.call([1, 2, 3]); // "[object Array]"


# 1: 闭包和递归：：：：：：：：：：：：：：：：：：：：：：：

闭包就是能够读取其他函数内部变量的函数。
function a() {
  let pa = 'a的变量'
  const b = () => {
    let pb = 'b的变量'
  }
}
const c = a.b
console.log('闭包就是能够读取其他函数内部变量的函数。', c)

function fun(a) {
  function f2() {
    console.log(a);
  }
  return f2;
}
let fn = fun(1)
console.log(fn)
setTimeout(fn, 1000)


function f1() {
  var sum = 0;
  console.log('111sum', sum)
  var obj = {
    inc: function (e) {
      console.log(sum, e, 'sum')
      sum++;
      return sum;
    }
  };
  return obj;
}
let result = f1();
console.log(result.inc());//1
console.log(result.inc());//2
console.log(result.inc());//3


闭包使用场景：：：：：：：：：：：：：：：：：
1：setTimeout 原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果
2：回调
3：函数防抖 返回一个函数 参数是函数
4：封装私有变量 创建一个计数器
5：当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来定义这个模块。

MVVM，理解闭包的艺术：：：：：：：：：：：：：：：：：
https://juejin.cn/post/6844903619808985095

// 减少全局变量； 减少传递函数的参数量；



# 递归 -：：：：：：：：：：：：：：：：：：：：
const multiply = (A, B) => {
  if (A === 1) {
    return B;
  } else {
    return B + multiply(A - 1, B);
  }
};

# 扩展：函数柯里化：：
function curry(fn, args) {
  var length = fn.length;
  args = args || [];
  return function (...rest) {
    var _args = [...args, ...rest];
    return _args.length < length
      ? curry.call(this, fn, _args)
      : fn.apply(this, _args);
  }
}
var fn = curry(function (a, b, c) {
  console.log(a + b + c);
});
fn('a', 'b', 'c'); // abc
fn('a', 'b')('c'); // abc
fn('a')('b')('c'); // abc



forEach、map、filter、reduce、every、some的区别联系：：：：：：：：：：：
forEach：  让数组中的每一项做一件事
map： 让数组的通过某种计算产生一个新的数组
filter： 筛选出数组符合条件的项 组成一个新数组
reduce： 让数组的前项和后项做某种计算 并累计最终值   //[1,2,3,4,5].reduce((prev,next)=>return prev+next)
every： 检测数组的每一项是否符合条件 全部符合就是true
some： 检测数组中的某一项是否符合条件 一项符合即可
splice：操作函数：

# 对象操作：：：：：：：：：：：：：：：：：：：：：：：：：：：
var copy = Object.assign({}, obj)
var obj = { 0: 'a', 1: 'b', 2: 'c' } console.log(Object.keys(obj))---console: ['0', '1', '2'] console.log(Object.values(obj))----['a', 'b', 'c']
const obj = { foo: 'bar', baz: 42 }-----console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]   
var obj = { a: 'ss', b: 'bb', c: 'cc' }---------for (var i in obj) { console.log(i + '--------' + obj[i]) }
Object.defineProperty(obj, prop, descriptor)



# new WeakMap用法：：：：：：：：：：：：：：：：：：：：：：
WeakMap的作用就是可以更有效的垃圾回收、释放内存。
let myWm = new WeakMap()
// 删除键
myWm.delete(key);
// 设置键和值------------key只能是对象 myWm.set(()=>{}, 1) myWm.set(new Date(), '鑫空间');
myWm.set(key, value);
// 是否包含某键
myWm.has(key);
// 获取键对应的值
myWm.get(key);


# 6:React SSR + express 构建简单服务端渲染Demo      https://juejin.cn/post/6844903990497378318




# reduce 高级用法：https://juejin.cn/post/6844903669977055239
var res = arr.reduce((x, y) => x.concat(y), []);

var result = [
  { subject: 'math', score: 88 },
  { subject: 'chinese', score: 95 },
  { subject: 'english', score: 80 }
];
var dis = {
    math: 0.5,
    chinese: 0.3,
    english: 0.2
};
var res = result.reduce((accumulator, cur) => dis[cur.subject] * cur.score + accumulator, 0);


# 事件冒泡/事件捕获，事件代理（事件委托）：：：：：：：：：：：：：：：：：：：：：：：：：：：


原型和原型链 ：：：：：：：：：：：：：：：：：：：：：：：：：：：


33个基本知识：：：：：：：：：：

调用堆栈：

执行上下文是评估和执行 JavaScript 代码的环境的抽象概念

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO(后进先出)数据结构的栈，被用来存储代码运行时创建的所有执行上下文。


值类型(基本类型)：字符串(string)、数值(number)、布尔值(boolean)、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol http://es6.ruanyifeng.com/#docs/symbol )
• 符号(symbol)ES6 中新增------- 一个 symbol 实例可以被赋值到一个左值变量，还可以通过标识符检查类型 （可以非常有效的消除magic string和magic number）
var identity = Symbol()
var obj = {
  name: 'john',
  [identity]: 'hero'
}
obj.name   //'john'
obj[name]  //'john'
obj.identity   //undefined
obj[identity]  //'hero'
//当我们使用.来访问时，因为不存在这个key，所以就会返回undefined，也符合上方所写的

#?? 引用类型：对象（Object）、数组（Array）、函数（Function）
都具有对象特性，即可自由扩展属性
都有一个隐式原型 __proto__ 属性，属性值是一个普通的对象。

const obj = { a: 1 }
obj.toString
当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 __proto__（也就是它的构造函数的显式原型 prototype）中寻找
obj 对象并没有 toString 属性，之所以能获取到 toString 属性，是遵循了第四条规则，从它的构造函数 Object 的 prototype 里去获取。

判断数据类型：：：：：：Object.prototype.toString.call(type).slice(8, -1);

显式类型转换与隐式类型转换 ：：：：：：：：：：：：：：

'1' * 'a' //NaN
console.log([] == []) // false
console.log([] == ![]) // true
console.log([] !== [])  // true
console.log(NaN != NaN) // true
console.log(null == undefined) // true
console.log(null === undefined) // false

显式类型：Number()、parseInt()、parseFloat()

在JS的变量传递中，本质上都可以看成是值传递，只是这个值可能是基础数据类型，
也可能是一个引用地址，如果是引用地址，我们通常就说为引用传递。JS中比较特殊，
不能直接操作对象的内存空间，必须通过指针（所谓的引用）来访问。
; 堆 和 栈
let obj1 = { name: 'a' }
let obj2 = obj1
obj2.name = 'b'
console.log(obj1.name) // b
以上代码中，obj1 和 obj2 指向了同一个堆内存，obj1 赋值给 obj2，
实际上这个堆内存对象在栈内存的引用地址复制了一份给了 obj2，所以 obj1 和 obj2 指针都指向堆内存中的同一个。



typeOf用法和instanceof用法：：：：：：：：：：：：：：：：：

Undefined	“undefined”
Null	“object”
布尔值	“boolean”
数值	“number”
字符串	“string”
Symbol(ECMAScript 6 新增)	“symbol”
宿主对象(JS环境提供的，比如浏览器)	Implementation - dependent
函数对象	“function”
任何其他对象	“object”

作用：：：typeof可以判断数据类型，但是无法判断array和object，


# instanceof用法：
instanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。
作用：：：instanceof主要的目的是检测引用类型, 判断对象是Array, 还是RegExp!

eg：
function Foo(name) {
  this.name = name;
}
var f = new Foo('nick')

f instanceof Foo // true
f instanceof Object // true

f 的隐式原型 __proto__ 和 Foo.prototype


判断数组：：：
Array.isArray(target)


# 循环遍历函数集合： https://www.xiabingbao.com/post/loop/js-loop-speed.html

for循环 for (let k = 0; k < 10; k++) {}    能够随时 break 停止

for (let k = 0; k < 10; k++) { if(k>5){ 
 break;} console.log(k) }

while (i < len) {
    sum += arr[i] % 100;
    i++;
  }

   do {
    sum += arr[i] % 100;
    i++;
  } while (i < len);

forEach, map, reduce这几种方法是无法停止循环的，无论使用break还是return
forEach, map, reduce 3 个循环的时间差不多

forEach
[1, 2, 3, 4, 5].forEach((item) => {}


for-of 的简要介绍  for-of 循环速度前两次很低
一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。也就是说，for...of 循环内部调用的是数据结构的 Symbol.iterator 方法。

for...of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。

for-of 拿到的就是 value 本身，而 for-in 则拿到的是 key，然后通过 key 再获取到当前数据。

for (const value of arr) {
    sum += value % 100;
  }


for-in 循环   循环效率真的很低!!!!!!
for-in 通常用于 object 类型的循环，但也可以用来循环数组，毕竟所有数据类型的祖先都是 object 类型。

for (let key in arr) {
    sum += arr[key] % 100;
  }




eventBus：：：：：：：：：：：：：：：：：：：：：：：

# JS 设计模式23种
代理模式：
let Flower = function() {}
let xiaoming = {
  sendFlower: function(target) {
    let flower = new Flower()
    target.receiveFlower(flower)
  }
}
let B = {
  receiveFlower: function(flower) {
    A.listenGoodMood(function() {
      A.receiveFlower(flower)
    })
  }
}
let A = {
  receiveFlower: function(flower) {
    console.log('收到花'+ flower)
  },
  listenGoodMood: function(fn) {
    setTimeout(function() {
      fn()
    }, 1000)
  }
}
xiaoming.sendFlower(B)
状态模式
观察者模式


JS的20个实用技巧：：：：：：：：：：：：：：：：：   https://juejin.cn/post/7083016475547533348


const {a,b,c,d,e} = obj || {};


const a = [1,2,3];
const b = [1,5,6];
const c = [...new Set([...a,...b])];//[1,2,3,5,6]

const obj1 = {
  a:1,
}
const obj2 = {
  b:1,
}
const obj = {...obj1,...obj2};

如果是精确搜索不会用ES6中的find吗？性能优化懂么，find方法中找到符合条件的项，就不会继续遍历数组。
const a = [1,2,3,4,5];
const result = a.find( 
  item =>{
    return item === 3
  }




使用reduce实现数组filter方法
const myFilter2 = function (fn, context) {
  return this.reduce((total, current, index) => {
    return fn.call(context, current, index, this) ? [...total, current] : [...total]
  }, [])
}



#!!!  前端遍历合集
https://owen027.github.io/2019/07/03/performance/

# 1：for
for (int i = 0; i < 10; i++) {

	continue // 后面的语句不执行，进入下一次 //  continue一般配合判断条件使用

  break // 跳出当前循环	 // 一般配合判断语句使用

  return 当程序运行到 return; 语句时，会终止循环，结束当前方法。
}

# 2： for( ...in )
for (let key in {a:1, b:2, c:3}) {
  console.log(key); /a b c
}

# 3： for( ...of )
for (let value of [1,2,3]) {
  console.log(value); /1 2 3
}

配合使用 Object.keys({a:1,b:2}) //[a,b]
for(var key of Object.keys({a:1, b:2, c:3})){
    console.log(key); 
}

#4： while 
var n = 0;
var x = 0;
while (n < 3) {
  n++;
  x += n;
}
console.log(n,x);//3 6

# 4.1：do-while
var i = 0;
do {
   i += 1;
   result += i + ' ';
} while (i < 5); 1 2 3 4 5

# 5： switch case 
const expr = 'Mangoes';
switch (expr) {
  case 'Oranges':
    console.log('Oranges are $0.59 a pound.');
    break;
  case 'Mangoes':
  case 'Papayas1':
    console.log('Mangoes and papayas are $2.79 a pound.');
    // expected output: "Mangoes and papayas are $2.79 a pound."
    break;
  default:
    console.log(`Sorry, we are out of ${expr}.`);
}

# 6：forEach()
遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次 .无法break中途跳出循环 不可控
forEach删除自身元素index不会被重置
arr.forEach((item, index) => {
    arr.splice(index, 1);
}); 当index=0,时 进入删除,然后进入下一次遍历index=1,而此时index=1 的项是第三项

创建新数组 不改变原数组  输出的是 return什么就输出什么 新数组
map 生成的新数组元素是可自定义。与filter相反
回调函数参数,item(数组元素)、index(序列)、arr(数组本身)

# 8：find()
和filter相似 输出的是一旦判断为true 则跳出循环输出符合条件的数组元素

# 9：some()
判断出一个符合条件则跳出循环并输出true

# 10：every()
判断出一个符合条件则跳出循环并输出true

# 11：filter
创建新数组 不改变原数组 输出的是 判断为true的数组元素 组成的新数组
filter 生成的新数组元素不可自定义，与对应原数组元素一致。
回调函数参数，item(数组元素)、index(序列)、arr(数组本身)
arr.filter(function(item,index){ return item>2&&item<5 })

# 12：findIndex 和 find一样 只是返回的是索引

# 13：reduce
创建新数组 不改变原数组 输出的是return叠加什么就输出什么 新数组
pre(第一次为数组第一项，之后为上一操作的结果)
next(数组的下一项)
index(next项的序列)
arr(数组本身)
回调函数后的改变第一项参数。（不影响原数组）




## forEach 解决方案
[...arr].forEach((item, index) => {
    arr.splice(index, 1);
    console.log(1);
});



# 懒加载也叫延迟加载

# 预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。
组件: createjs 中的 preloadjs
let mainfest = ['img1','img2']
 startPreload() {
    var preload = new createjs.LoadQueue(true);
    //为preloaded添加整个队列变化时展示的进度事件
    preload.addEventListener('progress', this.handleFileProgress);
    //为preloaded添加当队列完成全部加载后触发事件
    preload.addEventListener('complete', this.loadComplete);
    //设置最大并发连接数  最大值为10
    preload.setMaxConnections(1);
    preload.loadManifest(this.mainfest);
  }
  // 当整个队列变化时展示的进度事件的处理函数
  handleFileProgress(event) {
    this.setState({
      num: Math.ceil(event.loaded * 100) + '%',
    });
  }
  loadComplete() {
    this.props.history.push({
      pathname: '/index',
    });
  }

# 按需加载
使用babel/plugin-syntax-dynamic-import插件

# 使用 "use strict" 指令
"use strict" 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。
它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。
"use strict" 的目的是指定代码在严格条件下执行。
严格模式下你不能使用未声明的变量。



##TYPESCRIPT（ts）
ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：

# 接口iterface 和 类型别名type 的关联和区别：：：：：：：：：
1：都可以描述 对象和函数
interface SetSister {
  name: string;
  (name: string, age: number): void;
}
2： 都可以扩展 但是 type是 & 。interface是extends
3： interface扩展是不可以重复
4: type可以并用两个接口, 而接口不可以并用接口
interface Admin {
  name: string;
  privileges: string[];
}
interface Employee {
  name: string;
  startDate: Date;
}
type UnknownEmployee = Employee | Admin;

# implements与extends的区别：：：：：：：：：：：：：：：：

extends继承，一个新的接口或者类，从父类或者接口继承所有的属性和方法，不可以重写属性，但可以重写方法
implements是对某个接口或者类型的实现继承，必须满足接口的类型规范。


泛型（Generics）是允许同一个函数接受不同类型参数的一种模板：：：：：：：：：：
T （Type）
K（Key）：表示对象中的键类型；
V（Value）：表示对象中的值类型；
E（Element）：表示元素类型。

1：function aname<T>(value: T): T {
  return value;
}
2：function identity<T, U>(value: T, message: U): T {
  console.log(message);
  return value;
}
3：const bname = <T>(x: T): T => {
	return x;
};
/**  Record<string, unknown> 相当于{ } */
  4：const cname = <T extends Record<string, unknown>>(x: T): T => x;
  5：const dname =
  <T1 extends Record<string, unknown>>(arg1: T1) =>
  <T2 extends Record<string, unknown>>(arg2: T2) => {
		return {arg1, arg2};
	};

  字符串枚举+常量枚举=异构枚举
  类型断言： <string>someValue =====  someValue as any
    Partial<T> 的作用就是将某个类型或者接口里的属性全部变为可选项 ?

      JSON数据格式转ts接口： http://ww7.jsontots.com/

      高级类型技巧： https://juejin.cn/post/6994102811218673700#heading-6



      class Greeter {
        // 静态属性
        static cname: string = "Greeter";
      // 成员属性
      greeting: string;

      // 构造函数 - 执行初始化操作
      constructor(message: string) {
        this.greeting = message;
  }

      // 静态方法
      static getClassName() {
    return "Class name is Greeter";
  }

      // 成员方法
      greet() {
    return "Hello, " + this.greeting;
  }
}

      let greeter = new Greeter("world");


      编译成ES5代码：：：：：：：：：：：：：：：：：：：

      "use strict";
      var Greeter = /** @class */ (function () {
        // 构造函数 - 执行初始化操作
        function Greeter(message) {
          this.greeting = message;
        }
    // 静态方法
    Greeter.getClassName = function () {
      return "Class name is Greeter";
    };
      // 成员方法
      Greeter.prototype.greet = function () {
      return "Hello, " + this.greeting;
    };
      // 静态属性
      Greeter.cname = "Greeter";
      return Greeter;
}());
      var greeter = new Greeter("world");
