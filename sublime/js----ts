export PUB_HOSTED_URL=https://pub.flutter-io.cn

分词/词法分析------解析/语法分析------代码生成

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词
法作用域。
ES6 还引入了 const,同样可以用来创建块作用域变量,但其值是固定的
（常量）。之后任何试图修改值的操作都会引起错误。

这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”
到了最上面。这个过程就叫作提升。
(只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。)
(函数声明会被提升，但是函数表达式却不会被提升。)   函数优先！！！！   再其次是变量

let myObject = {
  mealA: 'Breakfast',
  mealB: 'Lunch',
  mealC: 'Dinner'
};

for (var k in myObject) {
console.log( k, myObject[k] );
}

for (let [key, value] of Object.entries(meals)) {
  console.log(key + ':' + value);
}

Object.keys(myObject)

var myObject = Object.create( anotherObject );  

宏任务和微任务-：：：：：：：：：：：：：：：：：：：：
function add(xPromise,yPromise) {
 // Promise.all([ .. ])接受一个promise数组并返回一个新的promise，
 // 这个新promise等待数组中的所有promise完成
 return Promise.all( [xPromise, yPromise] )
 // 这个promise决议之后，我们取得收到的X和Y值并加在一起
 .then( function(values){
 // values是来自于之前决议的promisei的消息数组
 return values[0] + values[1];
 } );
}
// fetchX()和fetchY()返回相应值的promise，可能已经就绪，
// 也可能以后就绪
add( fetchX(), fetchY() )
// 我们得到一个这两个数组的和的promise
// 现在链式调用 then(..)来等待返回promise的决议
.then( function(sum){
 console.log( sum ); // 这更简单！
} ); 


eg例子：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
1  7 6 8 2 4 3 5 9  10 11 12

eg:  6之后执行8  是因为 6是第一个微服务 执行完微服务要执行所有的微服务

eg: 2，4 ，3，5     ,,24之后要执行完这里的微服务再执行下面的微服务。下面的setimeOut是第三轮的事件循环宏服务


console.log('1');
setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

process.nextTick(function() {
    console.log('6');
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})


Promise.race或者  new promise 内部设置回调

promise的信任问题：：：：：：：：：：：：：：
// 不要只是这么做：
foo( 42 )
.then( function(v){
 console.log( v );
} );
// 而要这么做：
Promise.resolve( foo( 42 ) )
.then( function(v){
 console.log( v );
} ); 


Promise.all() 允许同时执行所有的异步函数：：：：：：：：：

扩展：
Promise
在 pending 状态，promise 可以切换到 fulfilled 或 rejected。
在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。
在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。


Async/Await - 定义异步函数
自动把函数转换为 Promise
当调用异步函数时，函数返回值会被 resolve 处理
异步函数内部可以使用 await

EG：：：：：：
多个异步函数同时执行时，需要借助 Promise.all
await 把异步变成了同步。
async function getABC() {
  let A = await getValueA();  getValueA 花费 2 秒
  let B = await getValueB();  getValueA 花费 4 秒
  let C = await getValueC();  getValueA 花费 3 秒

  return A*B*C;总花费9秒

  return await Promise.all([ getValueA, getValueB, getValueC ]); 总花费4秒
}






call bind apply用法：：：：https://zhuanlan.zhihu.com/p/82340026

1：call
(function(name) {
        //
    })("aa");
    //等价于
    (function(name) {
        //
    }).call(window, "aa");

函数作为对象的方法被调用(那么this就是这对象)

function hellofn(thing) {
  console.log(this + " says hello " + thing);
}

let person = { name: "caibirdme" };
person.hellofn = hellofn;
person.hellofn("world");//[object Object] says hello world
//相当于person.hellofn(person,"world")

person.innerobj = {
    name: "innerobjname",
    f: function(){ console.log(this.name); }
}
person.innerobj.f(); // 相当于obj.innerobj.f.call(obj.innerobj)
// ==> innerobjname


(call apply 本质是一样的但是接受参数的方式可能不一样：：：：：：：：：：：：
func.call(this, arg1, arg2)
func.apply(this, [arg1, arg2]))

验证是否是数组：functionisArray(obj){ 
    return Object.prototype.toString.call(obj) === '[object Array]' ;
}

var args = Array.prototype.slice.call(arguments); arguments是伪数组
  args.unshift('(app)');
   console.log.apply(console, args);

apply 、 call 、bind 三者都是用来改变函数的this对象的指向的
apply 、 call 、bind 三者第一个参数都是this要指向的对象,也就是想指定的上下文
apply 、 call 、bind 三者都可以利用后续参数传参
bind 是返回对应函数,便于稍后调用,apply 、call 则是立即调用 。

//  const obj = {
//     x: 10
//   }
//   function fn() {
//     console.log(this)
//   }
//   fn.call(obj)      //obj
//   fn.apply(obj) //obj
//   fn.bind(obj)() //obj

// 4.1: 判断类型
// Object.prototype.toString.call(null); // "[object Null]"
// Object.prototype.toString.call(undefined); // "[object Undefined]"
// Object.prototype.toString.call(“abc”);// "[object String]"
// Object.prototype.toString.call(123);// "[object Number]"
// Object.prototype.toString.call(true);// "[object Boolean]"
// Object.prototype.toString.call(new Date()); // "[object Date]"
// Object.prototype.toString.call([1,2,3]); // "[object Array]"


// 1: 闭包和递归：：：：：：：：：：：：：：：：：：：：：：：

// 闭包就是能够读取其他函数内部变量的函数。
// function a() {
//   let pa = 'a的变量'
//   const b = () => {
//     let pb = 'b的变量'
//   }
// }
// const c = a.b
// console.log('闭包就是能够读取其他函数内部变量的函数。', c)

// function fun(a) {
//   function f2() {
//     console.log(a);
//   }
//   return f2;
// }
// let fn = fun(1)
// console.log(fn)
// setTimeout(fn, 1000)


// function f1() {
//   var sum = 0;
//   console.log('111sum', sum)
//   var obj = {
//     inc: function (e) {
//       console.log(sum, e, 'sum')
//       sum++;
//       return sum;
//     }
//   };
//   return obj;
// }
// let result = f1();
// console.log(result.inc());//1
// console.log(result.inc());//2
// console.log(result.inc());//3


闭包使用场景：：：：：：：：：：：：：：：：：
1：setTimeout 原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果
2：回调
3：函数防抖 返回一个函数 参数是函数
4：封装私有变量 创建一个计数器
5：当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来定义这个模块。

MVVM，理解闭包的艺术：：：：：：：：：：：：：：：：：
https://juejin.cn/post/6844903619808985095

// 减少全局变量； 减少传递函数的参数量；



递归-：：：：：：：：：：：：：：：：：：：：
const multiply = (A, B) => {
   if (A === 1) {
      return B;
    } else {
      return B + multiply(A - 1, B);
    }
  };

扩展：函数柯里化：：
function curry(fn, args) {
  var length = fn.length;
  args = args || [];
  return function(...rest) {
    var _args = [...args, ...rest];
    return _args.length < length
      ? curry.call(this, fn, _args)
    : fn.apply(this, _args);
  }
}
var fn = curry(function(a, b, c) {
  console.log(a + b + c);
});
fn('a', 'b', 'c'); // abc
fn('a', 'b')('c'); // abc
fn('a')('b')('c'); // abc



forEach、map、filter、reduce、every、some的区别联系：：：：：：：：：：：
forEach：  让数组中的每一项做一件事
map： 让数组的通过某种计算产生一个新的数组  
filter： 筛选出数组符合条件的项 组成一个新数组
reduce： 让数组的前项和后项做某种计算 并累计最终值   //[1,2,3,4,5].reduce((prev,next)=>return prev+next)
every： 检测数组的每一项是否符合条件 全部符合就是true
some： 检测数组中的某一项是否符合条件 一项符合即可

 5: HOC高阶组件
 const HOC = (Com) => {
     return class tar extends Component<IProps, IState> {
         constructor(props: IProps) {
             super(props);
        }
         render() {
             return <div>
                 <Com  {...this.props}  > </Com>
             </div>
         }
     }
 }

//调用:
// HOC(组件名)


react类组件和hooks对比：：：：：：：：：：：：：：：：：：：：：：：：：：
// constructor ------   useState
// getDerivedStateFromProps --------  useState 里面 update 函数
// shouldComponentUpdate ------ useMemo
// render ------    函数本身
// componentDidMount ------ useEffect
// componentDidUpdate ------    useEffect
// componentWillUnmount ------  useEffect 里面返回的函数
// componentDidCatch ------ 无
// getDerivedStateFromError ------  无

命令式 VS 声明式
去生命周期化
去this 化
编译和压缩----对于构建工具来说,class 不能很好的压缩并且会使热重载出现不稳定的情况
性能------hook完成时间短

new WeakMap用法：：：：：：：：：：：：：：：：：：：：：：
WeakMap的作用就是可以更有效的垃圾回收、释放内存。
let myWm = new WeakMap()
// 删除键
myWm.delete(key);
// 设置键和值------------key只能是对象 myWm.set(()=>{}, 1) myWm.set(new Date(), '鑫空间');
myWm.set(key, value);
// 是否包含某键
myWm.has(key);
// 获取键对应的值
myWm.get(key);



如何让localStorage支持过期时间设置：：：：：：：：：：：：：：  https://juejin.cn/post/7040671388025225229

const store = {
  // 存储过期时间映射
  setExpireMap: (key, expire) => {
    const expireMap = localStorage.getItem("EXPIRE_MAP") || "{}";
    localStorage.setItem(
      "EXPIRE_MAP",
      JSON.stringify({
        ...JSON.parse(expireMap),
        key: expire,
      })
    );
  },
  setItem: (key, value, expire) => {
    store.setExpireMap(key, expire);
    localStorage.setItem(key, value);
  },
  getItem: (key) => {
    // 在取值之前先判断是否过期
    const expireMap = JSON.parse(localStorage.getItem("EXPIRE_MAP") || "{}");
    if (expireMap[key] && expireMap[key] < Date.now()) {
      return localStorage.getItem(key);
    } else {
      localStorage.removeItem(key);
      return null;
    }
  },
};

222222222222222222222222222222222222
import { store } from "xijs";
// 设置带有过期时间的key
store.set("name", "dooring", Date.now() + 1000);
console.log(store.get("name"));
setTimeout(() => {
  console.log(store.get("name"));
}, 1000);

// 设置成功后的回调
store.set("dooring", "xuxiaoxi", Date.now() + 1000, (status, key, value) => {
  console.log("success");
});

6:React SSR + express 构建简单服务端渲染Demo      https://juejin.cn/post/6844903990497378318

reduce 高级用法：https://juejin.cn/post/6844903669977055239


原型和原型链 ：：：：：：：：：：：：：：：：：：：：：：：：：：：


33个基本知识：：：：：：：：：：

调用堆栈：

执行上下文是评估和执行 JavaScript 代码的环境的抽象概念

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。


值类型(基本类型)：字符串(string)、数值(number)、布尔值(boolean)、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol http://es6.ruanyifeng.com/#docs/symbol )
• 符号(symbol)ES6 中新增------- 一个 symbol 实例可以被赋值到一个左值变量，还可以通过标识符检查类型 （可以非常有效的消除magic string和magic number）
var identity = Symbol()
var obj = {
    name : 'john',
    [identity] : 'hero'
}
obj.name   //'john'
obj[name]  //'john'
obj.identity   //undefined
obj[identity]  //'hero'
//当我们使用.来访问时，因为不存在这个key，所以就会返回undefined，也符合上方所写的

引用类型：对象（Object）、数组（Array）、函数（Function）
都具有对象特性，即可自由扩展属性
都有一个隐式原型 __proto__ 属性，属性值是一个普通的对象。

const obj = { a:1 }
obj.toString
当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 __proto__（也就是它的构造函数的显式原型 prototype）中寻找
obj 对象并没有 toString 属性，之所以能获取到 toString 属性，是遵循了第四条规则，从它的构造函数 Object 的 prototype 里去获取。

判断数据类型：：：：：：Object.prototype.toString.call(type).slice(8, -1);

显式类型转换与隐式类型转换 ：：：：：：：：：：：：：：

'1' * 'a' //NaN
console.log([] == []) // false
console.log([] == ![]) // true
console.log([] !== [])  // true
console.log(NaN != NaN) // true
console.log(null == undefined) // true
console.log(null === undefined) // false

显式类型：Number()、parseInt()、parseFloat()


typeOf用法和instanceof用法：：：：：：：：：：：：：：：：：
Undefined	“undefined”
Null	“object”
布尔值	“boolean”
数值	“number”
字符串	“string”
Symbol (ECMAScript 6 新增)	“symbol”
宿主对象(JS环境提供的，比如浏览器)	Implementation-dependent
函数对象	“function”
任何其他对象	“object”
作用：：：typeof可以判断数据类型，但是无法判断array和object，


instanceof用法：instanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。
作用：：：instanceof主要的目的是检测引用类型,判断对象是Array,还是RegExp!

eg：
function Foo(name) {
  this.name = name;
}
var f = new Foo('nick')

f instanceof Foo // true
f instanceof Object // true

f 的隐式原型 __proto__ 和 Foo.prototype


判断数组：：：
Array.isArray(target)


获取一个永不重复的ID：
export function GenNonDuplicateID() {
  let str: string = "";
  str = Math.random().toString(36).substr(3);
  str += Date.now().toString(16).substr(4);
  return str;
}



*获取一个时间标准对象: const time= new Date(时间戳); Wed Jun 01 2022 12:00:00 GMT+0800 (中国标准时间)

*获取一个时间戳:  new Date('2022-06-01 16:00:00').getTime()  //获取一个时间戳 1654070400000



*获取当前时间日期格式： new Date().toLocaleString()      //'2022/6/1 13:55:02'

*获取当天的时间戳： let startTime1 = new Date(new Date().toLocaleDateString()).getTime();  当天0点 1654012800000
*获取当天指定时间的时间戳： let endTime1 = new Date(new Date().toLocaleDateString()).getTime() + 15 * 60 * 60 * 1000    当天 15:00
*获取当天指定时间的时间戳： let endTime1 = new Date(new Date().toLocaleDateString()).getTime() + 15 * 60 * 60 * 1000 -1   当天 14:59:59

*两个时间戳相隔时间：
function intervalTime(startTime, endTime) {
    var timeDiff = (endTime - startTime) //时间差
    let days = Math.floor(timeDiff / (24 * 3600 * 1000)); // 计算出天数
    let leavel1 = timeDiff % (24 * 3600 * 1000); // 计算天数后剩余的时间
    let hours = Math.floor(leavel1 / (3600 * 1000)); // 计算天数后剩余的小时数
    let leavel2 = timeDiff % (3600 * 1000); // 计算剩余小时后剩余的毫秒数
    let minutes = Math.floor(leavel2 / (60 * 1000)); // 计算剩余的分钟数
    let leavel3 = timeDiff % (3600 * 1000); // 计算剩余分钟后剩余的毫秒数
    let scends = Math.floor(leavel3 / (60 * 1000));

    console.log(`${days}天${hours}时${minutes}分${scends}秒`)

    return 111
}

*标准时间转日期格式： dateFormat("YYYY-mm-dd HH:MM:SS", new Date())  //2022-06-01 11:22:30
function dateFormat(fmt, date) {
    let ret
    const opt = {
        'Y+': date.getFullYear().toString(), // 年
        'm+': (date.getMonth() + 1).toString(), // 月
        'd+': date.getDate().toString(), // 日
        'H+': date.getHours().toString(), // 时
        'M+': date.getMinutes().toString(), // 分
        'S+': date.getSeconds().toString(), // 秒
        // 有其他格式化字符需求可以继续添加，必须转化成字符串
    }
    for (let k in opt) {
        ret = new RegExp('(' + k + ')').exec(fmt)
        if (ret) {
            fmt = fmt.replace(ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, '0'))
        }
    }
    return fmt
}










eventBus：：：：：：：：：：：：：：：：：：：：：：：



JS的20个实用技巧：：：：：：：：：：：：：：：：：   https://juejin.cn/post/7083016475547533348

使用reduce实现数组filter方法
const myFilter2 = function (fn, context) {
    return this.reduce((total, current, index) => {
        return fn.call(context, current, index, this) ? [...total, current] : [...total]
    }, [])
}

// 刷剑指offer（https://www.nowcoder.com/ta/coding-interviews）

// 算法基础知识-http://www.360doc.com/content/21/0518/19/37113458_977788938.shtml




export function eventBus() {
	const all: Dictionary<Array<Function>> = Object.create(null);

	return {
		/**
		 * Register an event handler for the given type.
		 *
		 * @param type	Type of event to listen for, or `"*"` for all events
		 * @param handler Function to call in response to given event
		 */
		on(type: string, handler: (event?: any) => void) {
			(all[type] || (all[type] = [])).push(handler);
		},

		/**
		 * Remove an event handler for the given type.
		 *
		 * @param type	Type of event to unregister `handler` from, or `"*"`
		 * @param handler Handler function to remove
		 */
		off(type: string, handler: (event?: any) => void) {
			if (all[type]) {
				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
			}
		},

		/**
		 * Invoke all handlers for the given type.
		 * If present, `"*"` handlers are invoked after type-matched handlers.
		 *
		 * Note: Manually firing "*" handlers is not supported.
		 *
		 * @param type  The event type to invoke
		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
		 */
		emit(type: string, evt: any) {
			(all[type] || []).slice().map(handler => {
				handler(evt);
			});
			(all['*'] || []).slice().map(handler => {
				handler(type, evt);
			});
		},
	};
}




ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
ts：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：

接口iterface 和 类型别名type 的关联和区别：：：：：：：：：
1：都可以描述 对象和函数
interface SetSister {
  name: string;
  (name: string, age: number): void;
}
2： 都可以扩展 但是 type是&--------interface是extends
3： interface扩展是不可以重复
4: type可以并用两个接口,而接口不可以并用接口
interface Admin {
  name: string;
  privileges: string[];
}
interface Employee {
  name: string;
  startDate: Date;
}
type UnknownEmployee = Employee | Admin;

implements与extends的区别：：：：：：：：：：：：：：：：

extends继承，一个新的接口或者类，从父类或者接口继承所有的属性和方法，不可以重写属性，但可以重写方法
implements是对某个接口或者类型的实现继承，必须满足接口的类型规范。


泛型（Generics）是允许同一个函数接受不同类型参数的一种模板：：：：：：：：：：
T （Type）
K（Key）：表示对象中的键类型；
V（Value）：表示对象中的值类型；
E（Element）：表示元素类型。

1：function aname<T>(value: T): T {
	return value;
}
2：function identity <T, U>(value: T, message: U) : T {
  console.log(message);
  return value;
}
3：const bname = <T>(x: T): T => {
	return x;
};
/**  Record<string, unknown> 相当于{} */
4：const cname = <T extends Record<string, unknown>>(x: T): T => x;
5：const dname =
	<T1 extends Record<string, unknown>>(arg1: T1) =>
	<T2 extends Record<string, unknown>>(arg2: T2) => {
		return { arg1, arg2 };
	};

字符串枚举+常量枚举=异构枚举
类型断言： <string>someValue =====  someValue as any 
Partial<T> 的作用就是将某个类型或者接口里的属性全部变为可选项 ?

JSON数据格式转ts接口： http://ww7.jsontots.com/

高级类型技巧： https://juejin.cn/post/6994102811218673700#heading-6



 class Greeter {
  // 静态属性
  static cname: string = "Greeter";
  // 成员属性
  greeting: string;

  // 构造函数 - 执行初始化操作
  constructor(message: string) {
    this.greeting = message;
  }

  // 静态方法
  static getClassName() {
    return "Class name is Greeter";
  }

  // 成员方法
  greet() {
    return "Hello, " + this.greeting;
  }
}

let greeter = new Greeter("world");


编译成ES5代码：：：：：：：：：：：：：：：：：：：

"use strict";
var Greeter = /** @class */ (function () {
    // 构造函数 - 执行初始化操作
    function Greeter(message) {
      this.greeting = message;
    }
    // 静态方法
    Greeter.getClassName = function () {
      return "Class name is Greeter";
    };
    // 成员方法
    Greeter.prototype.greet = function () {
      return "Hello, " + this.greeting;
    };
    // 静态属性
    Greeter.cname = "Greeter";
    return Greeter;
}());
var greeter = new Greeter("world");
