基础包结构：：：：
react 
react-dom
react-reconciler
scheduler

两大循环：：：：：：：
任务调度循环------scheduler中
fiber构造循环-----react-reconciler中


react应用的启动过程：：：：：：：：：：：：：：：：：：：：
1：：创建ReactDOMRoot对象
const reactDOMRoot = ReactDOM.createRoot(document.getElementById('root'));
2：：调用reactDOMRoot.render(<App />); //不支持回调
3：：创建 fiberRoot 对象
调用一个相同的函数createRootImpl---最后就是创建fiberRoot对象(return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks))
4：：处理更新
4.1：：Scheduler(调度器)—— 调度任务的优先级，高优任务优先进入Reconciler；
4.2：：Reconciler(协调器)——负责找出变化的组件：更新工作从递归变成了可以中断的循环过程Reconciler内部采用了Fiber的架构。
react-reconciler作用：：：：：：：：：
调用组件的render方法,将返回的JSX转化为虚拟DOM
将虚拟DOM和上次更新时的虚拟DOM对比
通过对比找出本次更新中变化的虚拟DOM
真实DOM： <li>a</li>  虚拟DOM： let vnode = h('li','a'),
4.2.1：：
React 算法之调和diff算法 ：：：：：：：
深度优先算法----Diff算法比较只会在同层级进行, 不会跨层级比较
比较oldfiber.key 
如 key 相同, 进一步比较fiber.elementType与newChild.type
如 type 相同, 调用useFiber, 创建oldFiber.alternate,（老节点的链表头）并返回
如 type 不同, 调用createFiber创建新的fiber

在进行子节点的 diff算法 过程中，会进行 旧首节点和新首节点的sameNode对比，这一步命中了逻辑，因为现在新旧两次首部节点 的 key 都是 0了，同理，key为1和2的也是命中了逻辑，导致相同key的节点会去进行patchVnode更新文本，而原本就有的c节点，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行patchVnode更新文本，最后一个进行了新增，那就解释了为什么所有li标签都更新了。

4.3：：Renderer(渲染器)———— 负责将变化的组件渲染到页面上
    react-reconciler
    const reconcilerInstance = Reconciler(hostConfig);
    const container = reconcilerInstance.createContainer(containerDom, false, false);


; React、Vue2、Vue3的三种Diff算法：：：：：：https://juejin.cn/post/6919376064833667080#heading-14

React 递增法  通过 index  preList  nextList

; Vue2.X Diff —— 双端比较
Vue.js使用了一种称为Virtual DOM的技术来提高渲染性能，而Virtual DOM 的实现主要基于两个算法：diff算法和patch算法。
其中，diff算法用于计算新旧虚拟DOM树的差异，patch算法则用于将计算出的差异应用到真实DOM上。
Vue.js的diff算法主要采用了双端比较的策略。它通过遍历新旧虚拟DOM树的节点来找到差异。
具体来说，算法会同时从新旧节点的首尾两端开始比较，逐步向中间靠拢。在比较过程中，如果发现新旧节点相同，
则直接进入下一个节点的比较。如果发现新旧节点不同，则根据一定的策略（如节点的key属性或tag名称）
判断是要创建、更新、移动、删除节点。比如，如果新节点的key值与旧节点的key值相同，则说明这两个节点是同一个节点，
只需要更新其内容即可。如果新节点的key值在旧节点中不存在，则说明需要创建一个新节点。如果新节点的key值与旧节点中的其他节点的key值相同，
则说明需要将当前节点移动到对应节点的位置上。如果发现旧节点有但新节点没有，则说明需要删除旧节点。
在比较完节点之后，diff算法会对需要更新的节点进行更新操作。具体来说，Vue.js会根据需要更新的节点以及差异类型，生成一组针对真实DOM的操作指令。这些指令包括插入节点、删除节点、移动节点、更新节点等等。最后，Vue.js通过执行这些操作指令，将计算出的差异应用到真实DOM上，完成渲染过程。
需要注意的是，由于diff算法是一种计算量较大的算法，因此Vue.js会通过一些优化手段来提高算法的性能。例如，Vue.js会缓存一些常用的节点、限制比较的深度、跳过静态节点等等。这些优化手段可以有效地减少diff算法的计算量，提高Vue.js的渲染性能。

Vue3 Diff —— 最长递增子序列


React 中的优先级管理 ：：：：：：：：
可中断渲染,
时间切片(time slicing),
异步渲染(suspense)等特性, 在源码中得以实现都依赖于优先级管理.


// 优化
// useState
// useReducer

// setState 就是用 useReducer 实现的,useState 返回的函数内部封装了一个 dispatch。
// 那就是 useState 不对状态做浅层合并了，而 useReducer 会合并

ahooks源码:https://github1s.com/alibaba/hooks/blob/HEAD/packages/hooks/src/useLockFn/index.ts
          演示地址：https://ahooks.js.org/zh-CN/hooks/use-lock-fn/

调度实现(Scheduler) ：：：：：：：：：：：：：：：：：：：：：：：：
export let requestHostCallback; // 请求及时回调: port.postMessage
export let cancelHostCallback; // 取消及时回调: scheduledHostCallback = null
export let requestHostTimeout; // 请求延时回调: setTimeout
export let cancelHostTimeout; // 取消延时回调: cancelTimeout
export let shouldYieldToHost; // 是否让出主线程(currentTime >= deadline && needsPaint): 让浏览器能够执行更高优先级的任务(如ui绘制, 用户输入等)
export let requestPaint; // 请求绘制: 设置 needsPaint = true
export let getCurrentTime; // 获取当前时间
export let forceFrameRate; // 强制设置 yieldInterval (让出主线程的周期). 这个函数虽然存在, 但是从源码来看, 几乎没有用到

fiber 树构造 ：：：：：：：：：：：：：：：：：：：：：
初次创建：
FiberNode{
tag: 1
key: null
elementType: ƒ Content() {}
type: ƒ Content() {}
stateNode: Content
return: FiberNode
child: FiberNode
sibling: null
index: 1
ref: null
pendingProps: Object
memoizedProps: Object
}
对比更新：
FiberNode {
tag: 1
key: null
elementType: ƒ App() {}
type: ƒ App() {}
stateNode: App
return: FiberNode
child: FiberNode
sibling: null
index: 0
ref: null
pendingProps: Object
memoizedProps: Object
updateQueue: Object
memoizedState: Object
dependencies: null
mode: 8
flags: 5
nextEffect: null
firstEffect: null
lastEffect: null
lanes: 1
childLanes: 0
alternate: FiberNode                  
actualDuration: 3.700000047683716}

初次创建时fiber节点没有比较对象, 所以在向下生成子节点的时候没有任何多余的逻辑, 只管创建就行.
对比更新时需要把ReactElement对象与旧fiber对象进行比较, 来判断是否需要复用旧fiber对象. alternate更新的fliber有值

fiber 树渲染：：：：：：：：：：：：：：：：：：
整个渲染逻辑都在commitRoot 函数




React 算法之深度优先遍历：：：：：：：：：：：：：：：：：：：：

JS this的指向 
1：this永远指向一个对象
2：this的指向完全取决于函数调用的位置

eg：
const obj = {
    display: function(){
         console.log(this); 
    }
}
const fun = obj.display;
fun();  打印出来为window


# 在JS中，数组、函数、对象都是引用类型，在参数传递时也就是引用传递；

# !! react  this指向  https://blog.csdn.net/weixin_54217534/article/details/127788679
在 React 的类组件中，当我们把事件处理函数引用作为回调传递过去，如下所示：
<button type="button" onClick={this.handleClick}>Click Me</button>

# 原因：
onClick中的this是指向实例对象的，
所以可以在实例对象的原型上找到handleClick方法，
当点击该按钮后，handleClick方法中的this则会变成undefined，
类似于将对象中的方法赋给了其他变量，然后该变量再调用，就丢失了绑定的上下文

# 箭头函数解决：
因为箭头函数的this跟外层普通函数的this指向是一样的，所以this是指向实例对象的，且是直接指向，故方法内的this指向实例

# 定义的方法写成回调函数的形式解决
因为箭头函数的this只跟外层普通函数this有关

# 使用bind去改变this指向解决，因为bind改变指向后，无论 怎么调用该方法，都是指向bind传入的对象
<button type="button" onClick={this.handleClick.bind(this)}>Click Me</button>



# react是同步还是异步 ：：：：：：：：：：：：：：：：：：：：：：：
这里所说的同步异步， 并不是真正的同步异步， 它还是同步执行的。
这里的异步指的是多个state会合成到一起进行批量更新。


ES5 ES6继承的区别：：：：：：：：：：：：：：：
function class  
super 
class 声明内部会启用严格模式。


React Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。
而 Vue 的响应式机制使 setup() 只需要在初始化时调用一次，状态通过引用储存在 setup() 的闭包内。这也是vue不受调用顺序限制的原因。



调度阶段(reconciliation)：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。
渲染阶段(commit)：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上。



Reconciler采用递归的方式创建虚拟DOM,递归过程是不能中断的。如果组件树的层级很深,递归会占用线程很多时间,递归更新时间超过了16ms,用户交互就会卡顿。
(Fiber Reconciler 用链表遍历的方式替代了 React 16 之前的栈递归方案)

接受输入事件
执行事件回调
开始一帧
执行 RAF (RequestAnimationFrame)
页面布局，样式计算
绘制渲染
执行 RIC (RequestIdelCallback)

第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。

基于以上原因，在React中实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。


Concurrent Mode 指的就是 React 利用上面 Fiber 带来的新特性的开启的新模式 (mode)。 react17开始支持concurrent mode，这种模式的根本目的是为了让应用保持cpu和io的快速响应，它是一组新功能，包括Fiber、Scheduler、Lane，可以根据用户硬件性能和网络状况调整应用的响应速度，核心就是为了实现异步可中断的更新。concurrent mode也是未来react主要迭代的方向。



ref：：：：
当这个reactElement开始挂载时会先将他包装成一个ReactComponent。（没错，惊喜不惊喜，以外不意外，你随便写的一div,input标签都是先被封装成组件再挂载。）（instantiateReactComponent）


 5: HOC高阶组件
 const HOC = (Com) => {
     return class tar extends Component<IProps, IState> {
         constructor(props: IProps) {
             super(props);
        }
         render() {
             return <div>
                 <Com  {...this.props}  > </Com>
             </div>
         }
     }
 }

//调用:
// HOC(组件名)

react类组件和hooks对比：：：：：：：：：：：：：：：：：：：：：：：：：：
// constructor ------   useState
// getDerivedStateFromProps --------  useState 里面 update 函数
// shouldComponentUpdate ------ useMemo
// render ------    函数本身
// componentDidMount ------ useEffect
// componentDidUpdate ------    useEffect
// componentWillUnmount ------  useEffect 里面返回的函数
// componentDidCatch ------ 无
// getDerivedStateFromError ------  无

命令式 VS 声明式
去生命周期化
去this 化
编译和压缩----对于构建工具来说,class 不能很好的压缩并且会使热重载出现不稳定的情况
性能------hook完成时间短

# react 函数组件会捕获render内部的状态 https://overreacted.io/how-are-function-components-different-from-classes/


react 性能优化 ：：：：：：：：：：：：：：：：：：：：：：：：：：：
在 HTML 内实现 Loading 态或者骨架屏；
去掉外联 css；
缓存基础框架；
使用动态 polyfill；
使用 SplitChunksPlugin 拆分公共代码；
正确地使用 Webpack 4.0 的 Tree Shaking；
使用动态 import，切分页面代码，减小首屏 JS 体积；
编译到 ES2015+，提高代码运行效率，减小体积；
使用 lazyload 和 placeholder 提升加载体验。


## react-router  https://github.com/remix-run/react-router/blob/main/docs/getting-started/tutorial.md
lerna管理包 里面包含:
https://s2.51cto.com/images/blog/202202/14100830_6209b99e7c41892667.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=



## react-router-dom

react-router-dom 只是多了下面四个组件 BrowserRouter、 Link、NavLink、HashRouter， 其他其实都是直接引用 react-router 的。



# 下一代路由 reach router   (官网:https://reach.tech/router)





# 一文吃透 React SSR 服务端渲染和同构原理::::::::



## 新版react18：
在老版并发的React中，表示优先级的是一个被称为expirationTime的时间戳。比较更新是否应该被跳过 之后再来计算
在新版并发的React中，优先级被保存在31位的二进制数中。






; 函数 useCallback 详解
保存函数地址 优化性能


# 为什么保存了函数地址就可以提升性能
在 React 中，每当一个组件重新渲染时，所有的函数都会被重新创建。这意味着如果你在组件中定义了一个函数，并将其传递给子组件或者作为回调函数传递给其他 API，
那么每当组件重新渲染时，这个函数都会被重新创建。如果你的组件有很多这样的函数，并且这些函数都会在每次重新渲染时被重新创建，那么这可能会导致性能问题。
;因为每次创建函数都需要分配内存，并且需要进行垃圾回收，这可能会导致你的应用变得缓慢。

useCallback可以帮助你避免这个问题。当你使用 useCallback 时，React会检查函数的依赖项列表，并仅在依赖项发生变化时才重新创建函数。这意味着如果函数的依赖项没有发生变化，
那么保存了函数地址的引用就会被重复使用，而不需要重新创建新的函数。这可以帮助你避免不必要的函数创建，从而提高组件的性能。
需要注意的是，使用 useCallback 并不一定会带来性能提升，特别是在函数比较简单的情况下。因此，在使用 useCallback 时，你应该根据实际情况灵活使用，并根据需要对其进行优化。

（在函数比较简单的情况下，指的是函数的逻辑比较简单，没有复杂的计算逻辑或者对其他组件或 API 的大量调用）


# 保存函数地址是什么意思
在 JavaScript 中，函数也是一种对象，它们可以被赋值给变量、作为参数传递给其他函数、作为对象的属性等等。
保存函数地址，就是将一个函数的引用（也就是指向该函数的指针）存储在变量中，从而可以在以后的代码中引用该函数。

例如：在 React 中，如果你定义了一个函数并将其作为回调函数传递给子组件，那么每当组件重新渲染时，这个函数都会被重新创建。
如果你使用 useCallback 将该函数缓存起来，那么 React 就会将该函数的引用存储在一个变量中，从而可以在以后的代码中重复使用该函数。
保存函数地址可以帮助你避免不必要的函数创建，并提高代码的性能。在 React 中，使用 useCallback 可以帮助你缓存函数，从而避免不必要的函数创建，提高组件的性能。






; useLayoutEffect 详解
当组件所有DOM都渲染完成后，同步调用useLayoutEffect，然后再调用useEffect。

useLayoutEffect永远要比useEffect先触发完成。


; useImperativeHandle 详解
import React, { useRef, useImperativeHandle } from 'react';
import ReactDOM from 'react-dom';

const FancyInput = React.forwardRef((props, ref) => {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} type="text" />
});

const App = props => {
  const fancyInputRef = useRef();

  return (
    <div>
      <FancyInput ref={fancyInputRef} />
      <button
        onClick={() => fancyInputRef.current.focus()}      // 调用子组件的方法
      >父组件调用子组件的 focus</button>
    </div>
  )
}
ReactDOM.render(<App />, root);

# forwardRef 详解
想在函数组件中使用ref，就一定会用到forwardRef。
在函数组建中，props无法传递ref属性，而forwardRef可以多接受一个ref参数，从而实现ref在函数组件中的传递

传递一个函数

A————B——————C
forwardRef  直接 A---------C

const App = (props) => {
  const btnRef = React.createRef()		// 1
  useEffect(() => {
    console.log(btnRef)			// 5
  }, [btnRef]);
  return (
    <Button ref={btnRef}>一个按钮</Button>	// 2
  );
}

const Button = React.forwardRef((props, ref) => {	// 3
  return (
    <button
      ref={ref}			// 4
    >
      {props.children}
    </button>
  );
});

export default App;


# useCallback 源码解析
 function useCallback(callback, deps) {
  // 从 Hook 环境中获取当前的 Fiber 对象
  const fiber = getWorkInProgressFiber();

  // 获取或创建 memoizedState 对象
  const { memoizedState } = fiber;

  // 如果 memoizedState 对象不存在，或者依赖项有变化，就需要重新计算回调函数
  if (memoizedState === null || depsAreDifferent(deps, memoizedState.deps)) {
    const nextDeps = deps === undefined ? null : deps;
    // 创建一个新的 memoizedState 对象
    const newState = {
      deps: nextDeps,
      callback: callback,
      // 缓存一个 memoized 的回调函数
      // 该函数会调用最新的 callback 来执行实际的操作
      memoizedCallback: function(...args) {
        return newState.callback.apply(this, args);
      },
    };
    // 更新 fiber 对象的 memoizedState
    fiber.memoizedState = newState;
    return newState.memoizedCallback;
  }

  // 返回缓存的 memoized 回调函数
  return memoizedState.memoizedCallback;
}



##  源码解析
export function render(
  element: React$Element<any>,
  container: Container, 
  callback: ?Function,
) {

const internalContainerInstanceKey = '__reactContainer$' + randomKey;



function legacyRenderSubtreeIntoContainer(
    parentComponent: ? React$Component < any, any > ,
    children : ReactNodeList,
    container: Container,
    forceHydrate: boolean,
    callback: ? Function,
) {

    let fiberRoot: FiberRoot;

    function FiberRootNode(containerInfo, tag, hydrate) {
    this.tag = tag;
    this.containerInfo = containerInfo;
    this.pendingChildren = null;
    this.current = null;
    this.pingCache = null;
    this.finishedWork = null;
    this.timeoutHandle = noTimeout;
    this.context = null;
    this.pendingContext = null;
    this.isDehydrated = hydrate;
    this.callbackNode = null;
    this.callbackPriority = NoLane;
    this.eventTimes = createLaneMap(NoLanes);
    this.expirationTimes = createLaneMap(NoTimestamp);

    this.pendingLanes = NoLanes; //二进制
    this.suspendedLanes = NoLanes;
    this.pingedLanes = NoLanes;
    this.expiredLanes = NoLanes;
    this.mutableReadLanes = NoLanes;
    this.finishedLanes = NoLanes;

    this.entangledLanes = NoLanes;
    this.entanglements = createLaneMap(NoLanes);


function mountEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null,
): void {

  if (__DEV__) {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);
    }
  }
  if (
    __DEV__ &&
    enableStrictEffects &&
    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode
  ) {
    return mountEffectImpl(
      MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect,
      HookPassive,
      create,
      deps,
    );
  } else {
    return mountEffectImpl(
      PassiveEffect | PassiveStaticEffect,
      HookPassive,
      create,
      deps,
    );
  }
}  // 判断条件后执行mountEffectImpl

function mountEffectImpl(fiberFlags, hookFlags, create, deps): void {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,    //相当于第一参数
    undefined,
    nextDeps,  //相当于依赖项
  );
}


function mountRef<T>(initialValue: T): {|current: T|} {
  const hook = mountWorkInProgressHook();
  if (enableUseRefAccessWarning) {
    if (__DEV__) {
      // Support lazy initialization pattern shown in docs.
      // We need to store the caller stack frame so that we don't warn on subsequent renders.
      let hasBeenInitialized = initialValue != null;
      let lazyInitGetterStack = null;
      let didCheckForLazyInit = false;

      // Only warn once per component+hook.
      let didWarnAboutRead = false;
      let didWarnAboutWrite = false;

      let current = initialValue;
      const ref = {
        get current() {
          if (!hasBeenInitialized) {
            didCheckForLazyInit = true;
            lazyInitGetterStack = getCallerStackFrame();
          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {
            if (
              lazyInitGetterStack === null ||
              lazyInitGetterStack !== getCallerStackFrame()
            ) {
              didWarnAboutRead = true;
              console.warn(
                '%s: Unsafe read of a mutable value during render.\n\n' +
                  'Reading from a ref during render is only safe if:\n' +
                  '1. The ref value has not been updated, or\n' +
                  '2. The ref holds a lazily-initialized value that is only set once.\n',
                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',
              );
            }
          }
          return current;
        },
        set current(value) {
          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {
            if (
              hasBeenInitialized ||
              (!hasBeenInitialized && !didCheckForLazyInit)
            ) {
              didWarnAboutWrite = true;
              console.warn(
                '%s: Unsafe write of a mutable value during render.\n\n' +
                  'Writing to a ref during render is only safe if the ref holds ' +
                  'a lazily-initialized value that is only set once.\n',
                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',
              );
            }
          }

          hasBeenInitialized = true;
          current = value;
        },
      };
      Object.seal(ref);
      hook.memoizedState = ref;
      return ref;
    } else {
      const ref = {current: initialValue};
      hook.memoizedState = ref;
      return ref;
    }
  } else {
    const ref = {current: initialValue};
    hook.memoizedState = ref;
    return ref;
  }
}

function updateRef<T>(initialValue: T): {|current: T|} {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}


function mountMemo<T>(
  nextCreate: () => T,   //对应第一个参数
  deps: Array<mixed> | void | null,  //对应依赖项
): T {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();   // 执行一遍函数 返回执行后的结果进行一次处理
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}


function updateMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      const prevDeps: Array<mixed> | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {  //进行一次浅比较
        return prevState[0];
      }
    }
  }
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}


function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}


function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps: Array<mixed> | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

异步调用  //useEffect
同步调用  //useLayoutEffect

  useImperativeHandle<T>(
      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,
      create: () => T,
      deps: Array<mixed> | void | null,
    ): void {
      currentHookNameInDev = 'useImperativeHandle';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },


function mountImperativeHandle<T>(
  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,
  create: () => T,
  deps: Array<mixed> | void | null,
): void {
  if (__DEV__) {
    if (typeof create !== 'function') {
      console.error(
        'Expected useImperativeHandle() second argument to be a function ' +
          'that creates a handle. Instead received: %s.',
        create !== null ? typeof create : 'null',
      );
    }
  }

  // TODO: If deps are provided, should we skip comparing the ref itself?
  const effectDeps =
    deps !== null && deps !== undefined ? deps.concat([ref]) : null;

  let fiberFlags: Flags = UpdateEffect;
  if (enableSuspenseLayoutEffectSemantics) {
    fiberFlags |= LayoutStaticEffect;
  }
  if (
    __DEV__ &&
    enableStrictEffects &&
    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode
  ) {
    fiberFlags |= MountLayoutDevEffect;
  }
  return mountEffectImpl(
    fiberFlags,
    HookLayout,
    imperativeHandleEffect.bind(null, create, ref),
    effectDeps,
  );
}


例子：
    const checkboxRef = useMemo<CheckboxRef>(() => {
        return {
            root: rootRef.current,
            toggle: handleToggle,
        };
    }, [handleToggle]);

    useImperativeHandle<CheckboxRef, CheckboxRef>(ref, () => checkboxRef, [
        checkboxRef,
    ]);



调度阶段(reconciliation)：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法（深度优先算法）（ChildReconciler  return reconcileChildFibers ），快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。

function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    lanes: Lanes,   //react 17 优化
    //React16的expirationTimes模型只能区分是否>=expirationTimes决定节点
    //否更新。React17的lanes模型可以选定一个更新区间，并且动态的向区间中增减
    //优先级，可以处理更细粒度的更新。
  ): Fiber | null {}


  function reconcileChildrenArray(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChildren: Array<*>,
    lanes: Lanes,
): Fiber | null {
    // returnFiber：currentFirstChild的父级fiber节点
    // currentFirstChild：当前执行更新任务的WIP（fiber）节点
    // newChildren：组件的render方法渲染出的新的ReactElement节点
    // lanes：优先级相关
    
    
    // resultingFirstChild是diff之后的新fiber链表的第一个fiber。
    let resultingFirstChild: Fiber | null = null;
    // resultingFirstChild是新链表的第一个fiber。

    // previousNewFiber用来将后续的新fiber接到第一个fiber之后
    let previousNewFiber: Fiber | null = null;
    
    // oldFiber节点，新的child节点会和它进行比较
    let oldFiber = currentFirstChild;

    // 存储固定节点的位置
    let lastPlacedIndex = 0;

    // 存储遍历到的新节点的索引
    let newIdx = 0;

    // 记录目前遍历到的oldFiber的下一个节点
    let nextOldFiber = null;
    
    // 该轮遍历来处理节点更新，依据节点是否可复用来决定是否中断遍历
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
        // newChildren遍历完了，oldFiber链没有遍历完，此时需要中断遍历
        if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber; oldFiber = null;
        } else {
            // 用nextOldFiber存储当前遍历到的oldFiber的下一个节点
            nextOldFiber = oldFiber.sibling;
        }
        // 生成新的节点，判断key与tag是否相同就在updateSlot中
        // 对DOM类型的元素来说，key 和 tag都相同才会复用oldFiber
        // 并返回出去，否则返回null
        const newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes,
        );
        
        // newFiber为 null说明 key 或 tag 不同，节点不可复用，中断遍历
        if (newFiber === null) {
            if (oldFiber === null) {
            // oldFiber 为null说明oldFiber此时也遍历完了
            // 是以下场景，D为新增节点
            // 旧 A - B - C 
            // 新 A - B - C - D oldFiber = nextOldFiber;
            }
            break;
        }
        if (shouldTrackSideEffects) {
            // shouldTrackSideEffects 为true表示是更新过程
            if (oldFiber && newFiber.alternate === null) {
                // newFiber.alternate 等同于 oldFiber.alternate 
                // oldFiber为WIP节点，它的alternate 就是 current节点
                // oldFiber存在，并且经过更新后的新fiber节点它还没有current节点,
                // 说明更新后展现在屏幕上不会有current节点，而更新后WIP
                // 节点会称为current节点，所以需要删除已有的WIP节点
                deleteChild(returnFiber, oldFiber);
                }
            }
            // 记录固定节点的位置
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            // 将新fiber连接成以sibling为指针的单向链表
            if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
            } else {
                previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            // 将oldFiber节点指向下一个，与newChildren的遍历同步移动
            oldFiber = nextOldFiber;
         }
         
        // 处理节点删除。新子节点遍历完，说明剩下的oldFiber都是没用的了，可以删除.
        if (newIdx === newChildren.length) {
            // newChildren遍历结束，删除掉oldFiber链中的剩下的节点
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
        }
        
        // 处理新增节点。旧的遍历完了，能复用的都复用了，所以意味着新的都是新插入的了
        if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
            
                // 基于新生成的ReactElement创建新的Fiber节点
                const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                    continue;
                }
                // 记录固定节点的位置lastPlacedIndex
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); 
                // 将新生成的fiber节点连接成以sibling为指针的单向链表
                if (previousNewFiber === null) {
                    resultingFirstChild = newFiber;
                } else {
                    previousNewFiber.sibling = newFiber; 
                }
                previousNewFiber = newFiber;
            }
            return resultingFirstChild;
        }
        // 执行到这是都没遍历完的情况，把剩余的旧子节点放入一个以key为键,值为oldFiber节点的map中
        // 这样在基于oldFiber节点新建新的fiber节点时，可以通过key快速地找出oldFiber
        const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
        
        // 节点移动
        for (; newIdx < newChildren.length; newIdx++) {
            // 基于map中的oldFiber节点来创建新fiber
            const newFiber = updateFromMap( existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, ); 
            if (newFiber !== null) {
                if (shouldTrackSideEffects) {
                    if (newFiber.alternate !== null) {
                        // 因为newChildren中剩余的节点有可能和oldFiber节点一样,只是位置换了，
                        // 但也有可能是是新增的.
                        
                        // 如果newFiber的alternate不为空，则说明newFiber不是新增的。
                        // 也就说明着它是基于map中的oldFiber节点新建的,意味着oldFiber已经被使用了,所以需
                        // 要从map中删去oldFiber
                        existingChildren.delete(
                            newFiber.key === null ? newIdx : newFiber.key,
                        );
                     }
                  }
                  
                 // 移动节点，多节点diff的核心，这里真正会实现节点的移动
                 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                 // 将新fiber连接成以sibling为指针的单向链表
                if (previousNewFiber === null) {
                    resultingFirstChild = newFiber;
                } else {
                    previousNewFiber.sibling = newFiber; 
                }
                previousNewFiber = newFiber;
            }
         }
        if (shouldTrackSideEffects) {
           // 此时newChildren遍历完了，该移动的都移动了，那么删除剩下的oldFiber
           existingChildren.forEach(child => deleteChild(returnFiber, child));
        }
        return resultingFirstChild;
 }


